<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LLVM: llvm::SCEVAddRecExpr Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">mainline</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacellvm.html">llvm</a>      </li>
      <li class="navelem"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">llvm::SCEVAddRecExpr Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="llvm::SCEVAddRecExpr" --><!-- doxytag: inherits="llvm::SCEVNAryExpr" -->
<p><a class="el" href="classllvm_1_1SCEVAddRecExpr.html" title="SCEVAddRecExpr - This node represents a polynomial recurrence on the trip count of the specified loop...">SCEVAddRecExpr</a> - This node represents a polynomial recurrence on the trip count of the specified loop.  
 <a href="classllvm_1_1SCEVAddRecExpr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for llvm::SCEVAddRecExpr:</div>
<div class="dyncontent">
<div class="center"><img src="classllvm_1_1SCEVAddRecExpr__inherit__graph.png" border="0" usemap="#llvm_1_1SCEVAddRecExpr_inherit__map" alt="Inheritance graph"/></div>
<map name="llvm_1_1SCEVAddRecExpr_inherit__map" id="llvm_1_1SCEVAddRecExpr_inherit__map">
<area shape="rect" id="node2" href="classllvm_1_1SCEVNAryExpr.html" title="SCEVNAryExpr &#45; This node is a base class providing common functionality for n&#39;ary operators..." alt="" coords="13,160,163,189"/><area shape="rect" id="node4" href="classllvm_1_1SCEV.html" title="SCEV &#45; This class represents an analyzed expression in the program." alt="" coords="43,83,133,112"/><area shape="rect" id="node6" href="classllvm_1_1FoldingSetImpl_1_1Node.html" title="Node &#45; This class is used to maintain the singly linked bucket list in a folding set." alt="" coords="27,5,149,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for llvm::SCEVAddRecExpr:</div>
<div class="dyncontent">
<div class="center"><img src="classllvm_1_1SCEVAddRecExpr__coll__graph.png" border="0" usemap="#llvm_1_1SCEVAddRecExpr_coll__map" alt="Collaboration graph"/></div>
<map name="llvm_1_1SCEVAddRecExpr_coll__map" id="llvm_1_1SCEVAddRecExpr_coll__map">
<area shape="rect" id="node2" href="classllvm_1_1SCEVNAryExpr.html" title="SCEVNAryExpr &#45; This node is a base class providing common functionality for n&#39;ary operators..." alt="" coords="77,197,227,227"/><area shape="rect" id="node4" href="classllvm_1_1SCEV.html" title="SCEV &#45; This class represents an analyzed expression in the program." alt="" coords="84,101,175,131"/><area shape="rect" id="node6" href="classllvm_1_1FoldingSetImpl_1_1Node.html" title="Node &#45; This class is used to maintain the singly linked bucket list in a folding set." alt="" coords="5,5,128,35"/><area shape="rect" id="node8" href="classunsigned.html" title="unsigned" alt="" coords="152,5,232,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classllvm_1_1SCEVAddRecExpr-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a0d53a749bd858b270d322b34b8d7e1e5">getStart</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Loop.html">Loop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a7fcbbc51eef313e675a2442bb2053ae9">getLoop</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a443e9130cd9f3e3baaa1b566e6aa5060">getStepRecurrence</a> (<a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">getStepRecurrence - This method constructs and returns the recurrence indicating how much this expression steps by.  <a href="#a443e9130cd9f3e3baaa1b566e6aa5060"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a88f514461ddb0af0fc59ac4639f644bc">isAffine</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">isAffine - Return true if this represents an expression A + B*x where A and B are loop invariant values.  <a href="#a88f514461ddb0af0fc59ac4639f644bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#abcef7196d3d3fa9d61a5a2516892c676">isQuadratic</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">isQuadratic - Return true if this represents an expression A + B*x + C*x^2 where A, B and C are loop invariant values.  <a href="#abcef7196d3d3fa9d61a5a2516892c676"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a5316a2763777f3670c1606452f4e99d7">setNoWrapFlags</a> (<a class="el" href="classllvm_1_1SCEV.html#af43000d4dcb7d6d63cb6e36933ed3f6f">NoWrapFlags</a> Flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flags for a recurrence without clearing any previously set flags.  <a href="#a5316a2763777f3670c1606452f4e99d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a11bb31f99854303d2a934765469c5c2c">evaluateAtIteration</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *It, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluateAtIteration - Return the value of this chain of recurrences at the specified iteration number.  <a href="#a11bb31f99854303d2a934765469c5c2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a55749fb6ea63e413e3e39645dcc2963c">getNumIterationsInRange</a> (<a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> Range, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">getNumIterationsInRange - Return the number of iterations of this loop that produce values in the specified constant range.  <a href="#a55749fb6ea63e413e3e39645dcc2963c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#ada9969a271c8bab660bfb2aa01f22e76">getPostIncExpr</a> (<a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">getPostIncExpr - Return an expression representing the value of this expression one iteration of the loop ahead.  <a href="#ada9969a271c8bab660bfb2aa01f22e76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a625a4771a78786e5c3e305c31500f0fe">collectParametricTerms</a> (<a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;Terms) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect parametric terms occurring in step expressions.  <a href="#a625a4771a78786e5c3e305c31500f0fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a6cae85af7cbd0257beb8276542f2247b">computeAccessFunctions</a> (<a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;Subscripts, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;Sizes) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return in Subscripts the access functions for each dimension in Sizes.  <a href="#a6cae85af7cbd0257beb8276542f2247b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a9da2e8bae31490a038c31eee345aa882">delinearize</a> (<a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;Subscripts, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;Sizes, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *ElementSize) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split this <a class="el" href="classllvm_1_1SCEVAddRecExpr.html" title="SCEVAddRecExpr - This node represents a polynomial recurrence on the trip count of the specified loop...">SCEVAddRecExpr</a> into two vectors of SCEVs representing the subscripts and sizes of an array access.  <a href="#a9da2e8bae31490a038c31eee345aa882"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a93b096608fec2f6b2c6d5b4fec2dbb6c">classof</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for support type inquiry through isa, cast, and dyn_cast:  <a href="#a93b096608fec2f6b2c6d5b4fec2dbb6c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a15a0237aaba54972c69acad43448c093">ScalarEvolution</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classllvm_1_1SCEVAddRecExpr.html" title="SCEVAddRecExpr - This node represents a polynomial recurrence on the trip count of the specified loop...">SCEVAddRecExpr</a> - This node represents a polynomial recurrence on the trip count of the specified loop. </p>
<p>This is the primary focus of the <a class="el" href="classllvm_1_1ScalarEvolution.html" title="ScalarEvolution - This class is the main scalar evolution driver.">ScalarEvolution</a> framework; all the other <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a> subclasses are mostly just supporting infrastructure to allow <a class="el" href="classllvm_1_1SCEVAddRecExpr.html" title="SCEVAddRecExpr - This node represents a polynomial recurrence on the trip count of the specified loop...">SCEVAddRecExpr</a> expressions to be created and analyzed.</p>
<p>All operands of an AddRec are required to be loop invariant. </p>

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00288">288</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a93b096608fec2f6b2c6d5b4fec2dbb6c"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::classof" ref="a93b096608fec2f6b2c6d5b4fec2dbb6c" args="(const SCEV *S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a93b096608fec2f6b2c6d5b4fec2dbb6c">llvm::SCEVAddRecExpr::classof</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methods for support type inquiry through isa, cast, and dyn_cast: </p>

<p>Reimplemented from <a class="el" href="classllvm_1_1SCEVNAryExpr.html#a683f6ac8f67a2aa12754c196dc96c9e3">llvm::SCEVNAryExpr</a>.</p>

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00356">356</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>

<p>References <a class="el" href="ScalarEvolution_8h_source.html#l00105">llvm::SCEV::getSCEVType()</a>, and <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00031">llvm::scAddRecExpr</a>.</p>

</div>
</div>
<a class="anchor" id="a625a4771a78786e5c3e305c31500f0fe"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::collectParametricTerms" ref="a625a4771a78786e5c3e305c31500f0fe" args="(ScalarEvolution &amp;SE, SmallVectorImpl&lt; const SCEV * &gt; &amp;Terms) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a625a4771a78786e5c3e305c31500f0fe">SCEVAddRecExpr::collectParametricTerms</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Terms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Collect parametric terms occurring in step expressions. </p>
<p>Find parametric terms in this <a class="el" href="classllvm_1_1SCEVAddRecExpr.html" title="SCEVAddRecExpr - This node represents a polynomial recurrence on the trip count of the specified loop...">SCEVAddRecExpr</a>. </p>

<p>Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07650">7650</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p>References <a class="el" href="Debug_8cpp_source.html#l00123">llvm::dbgs()</a>, <a class="el" href="Debug_8h_source.html#l00092">DEBUG</a>, and <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00629">llvm::visitAll()</a>.</p>

<p>Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l07974">delinearize()</a>.</p>

</div>
</div>
<a class="anchor" id="a6cae85af7cbd0257beb8276542f2247b"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::computeAccessFunctions" ref="a6cae85af7cbd0257beb8276542f2247b" args="(ScalarEvolution &amp;SE, SmallVectorImpl&lt; const SCEV * &gt; &amp;Subscripts, SmallVectorImpl&lt; const SCEV * &gt; &amp;Sizes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a6cae85af7cbd0257beb8276542f2247b">SCEVAddRecExpr::computeAccessFunctions</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Subscripts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return in Subscripts the access functions for each dimension in Sizes. </p>
<p>Third step of delinearization: compute the access functions for the Subscripts based on the dimensions in Sizes.</p>

<p>Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07870">7870</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p>References <a class="el" href="SmallVector_8h_source.html#l00112">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::begin()</a>, <a class="el" href="SmallVector_8h_source.html#l00369">llvm::SmallVectorImpl&lt; T &gt;::clear()</a>, <a class="el" href="Debug_8cpp_source.html#l00123">llvm::dbgs()</a>, <a class="el" href="Debug_8h_source.html#l00092">DEBUG</a>, <a class="el" href="SmallVector_8h_source.html#l00057">llvm::SmallVectorBase::empty()</a>, <a class="el" href="SmallVector_8h_source.html#l00114">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::end()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00314">isAffine()</a>, <a class="el" href="InstrProfIndexed_8h_source.html#l00027">llvm::IndexedInstrProf::Last</a>, <a class="el" href="SmallVector_8h_source.html#l00222">llvm::SmallVectorTemplateBase&lt; T, isPodLike &gt;::push_back()</a>, and <a class="el" href="SmallVector_8h_source.html#l00127">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l07974">delinearize()</a>.</p>

</div>
</div>
<a class="anchor" id="a9da2e8bae31490a038c31eee345aa882"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::delinearize" ref="a9da2e8bae31490a038c31eee345aa882" args="(ScalarEvolution &amp;SE, SmallVectorImpl&lt; const SCEV * &gt; &amp;Subscripts, SmallVectorImpl&lt; const SCEV * &gt; &amp;Sizes, const SCEV *ElementSize) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a9da2e8bae31490a038c31eee345aa882">SCEVAddRecExpr::delinearize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Subscripts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *&#160;</td>
          <td class="paramname"><em>ElementSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split this <a class="el" href="classllvm_1_1SCEVAddRecExpr.html" title="SCEVAddRecExpr - This node represents a polynomial recurrence on the trip count of the specified loop...">SCEVAddRecExpr</a> into two vectors of SCEVs representing the subscripts and sizes of an array access. </p>
<p>Splits the <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a> into two vectors of SCEVs representing the subscripts and sizes of an array access.</p>
<p>The delinearization is a 3 step process: the first two steps compute the sizes of each subscript and the third step computes the access functions for the delinearized array:</p>
<p>1. Find the terms in the step functions 2. Compute the array size 3. Compute the access function: divide the <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a> by the array size starting with the innermost dimensions found in step 2. The Quotient is the <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a> to be divided in the next step of the recursion. The Remainder is the subscript of the innermost dimension. <a class="el" href="classllvm_1_1Loop.html">Loop</a> over all array dimensions computed in step 2.</p>
<p>To compute a uniform array size for several memory accesses to the same object, one can collect in step 1 all the step terms for all the memory accesses, and compute in step 2 a unique array shape. This guarantees that the array shape will be the same across all memory accesses.</p>
<p>FIXME: We could derive the result of steps 1 and 2 from a description of the array shape given in metadata.</p>
<p>Example:</p>
<p>A[][n][m]</p>
<p>for i for j for k A[j+k][2i][5i] =</p>
<p>The initial <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a>:</p>
<p>A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]</p>
<p>1. Find the different terms in the step functions: -&gt; [2*m, 5, n*m, n*m]</p>
<p>2. Compute the array size: sort and unique them -&gt; [n*m, 2*m, 5] find the GCD of all the terms = 1 divide by the GCD and erase constant terms -&gt; [n*m, 2*m] GCD = m divide by GCD -&gt; [n, 2] remove constant terms -&gt; [n] size of the array is A[unknown][n][m]</p>
<p>3. Compute the access function a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k The remainder is the subscript of the innermost array dimension: [5i].</p>
<p>b. Divide Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k by next outer size n Quotient: {{{0,+,0}_i, +, 1}_j, +, 1}_k Remainder: {{{0,+,2}_i, +, 0}_j, +, 0}_k The Remainder is the subscript of the next array dimension: [2i].</p>
<p>The subscript of the outermost dimension is the Quotient: [j+k].</p>
<p>Overall, we have: A[][n][m], and the access function: A[j+k][2i][5i].</p>
<p>Returns the remainder of the delinearization that is the offset start of the array. The SCEV-&gt;delinearize algorithm computes the multiples of <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a> coefficients: that is a pattern matching of sub expressions in the stride and base of a <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a> corresponding to the computation of a GCD (greatest common divisor) of base and stride. When SCEV-&gt;delinearize fails, it returns the <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a> unchanged.</p>
<p>For example: when analyzing the memory access A[i][j][k] in this loop nest</p>
<p>void foo(long n, long m, long o, double A[n][m][o]) {</p>
<p>for (long i = 0; i &lt; n; i++) for (long j = 0; j &lt; m; j++) for (long k = 0; k &lt; o; k++) A[i][j][k] = 1.0; }</p>
<p>the delinearization input is the following AddRec <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a>:</p>
<p>AddRec: {{{A,+,(8 * m * o)}&lt;for.i&gt;,+,(8 * o)}&lt;for.j&gt;,+,8}&lt;for.k&gt;</p>
<p>From this <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a>, we are able to say that the base offset of the access is A because it appears as an offset that does not divide any of the strides in the loops:</p>
<p>CHECK: Base offset: A</p>
<p>and then SCEV-&gt;delinearize determines the size of some of the dimensions of the array as these are the multiples by which the strides are happening:</p>
<p>CHECK: ArrayDecl[UnknownSize][m][o] with elements of sizeof(double) bytes.</p>
<p>Note that the outermost dimension remains of UnknownSize because there are no strides that would help identifying the size of the last dimension: when the array has been statically allocated, one could compute the size of that dimension by dividing the overall size of the array by the size of the known dimensions: m * o * 8.</p>
<p>Finally delinearize provides the access functions for the array reference that does correspond to A[i][j][k] of the above C testcase:</p>
<p>CHECK: <a class="el" href="classllvm_1_1ArrayRef.html" title="ArrayRef - Represent a constant reference to an array (0 or more elements consecutively in memory)...">ArrayRef</a>[{0,+,1}&lt;for.i&gt;][{0,+,1}&lt;for.j&gt;][{0,+,1}&lt;for.k&gt;]</p>
<p>The testcases are checking the output of a function pass: DelinearizationPass that walks through all loads and stores of a function asking for the <a class="el" href="classllvm_1_1SCEV.html" title="SCEV - This class represents an analyzed expression in the program.">SCEV</a> of the memory access with respect to all enclosing loops, calling SCEV-&gt;delinearize on that and printing the results. </p>

<p>Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07974">7974</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p>References <a class="el" href="ScalarEvolution_8cpp_source.html#l07650">collectParametricTerms()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l07870">computeAccessFunctions()</a>, <a class="el" href="Debug_8cpp_source.html#l00123">llvm::dbgs()</a>, <a class="el" href="Debug_8h_source.html#l00092">DEBUG</a>, <a class="el" href="SmallVector_8h_source.html#l00057">llvm::SmallVectorBase::empty()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l07803">llvm::ScalarEvolution::findArrayDimensions()</a>.</p>

</div>
</div>
<a class="anchor" id="a11bb31f99854303d2a934765469c5c2c"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::evaluateAtIteration" ref="a11bb31f99854303d2a934765469c5c2c" args="(const SCEV *It, ScalarEvolution &amp;SE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a11bb31f99854303d2a934765469c5c2c">SCEVAddRecExpr::evaluateAtIteration</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>evaluateAtIteration - Return the value of this chain of recurrences at the specified iteration number. </p>
<p>We can evaluate this recurrence by multiplying each element in the chain by the binomial coefficient corresponding to it. In other words, we can evaluate {A,+,B,+,C,+,D} as:</p>
<p>A*BC(It, 0) + B*BC(It, 1) + C*BC(It, 2) + D*BC(It, 3)</p>
<p>where BC(It, k) stands for binomial coefficient. </p>

<p>Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l01067">1067</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p>References <a class="el" href="ScalarEvolution_8cpp_source.html#l00948">BinomialCoefficient()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01970">llvm::ScalarEvolution::getAddExpr()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l02378">llvm::ScalarEvolution::getMulExpr()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00148">llvm::SCEVNAryExpr::getNumOperands()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00149">llvm::SCEVNAryExpr::getOperand()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00298">getStart()</a>, and <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00162">llvm::SCEVNAryExpr::getType()</a>.</p>

<p>Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l05224">EvaluateConstantChrecAtConstant()</a>, <a class="el" href="LoopAccessAnalysis_8cpp_source.html#l00115">llvm::LoopAccessInfo::RuntimePointerCheck::insert()</a>, and <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00784">llvm::SCEVApplyRewriter::visitAddRecExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="a7fcbbc51eef313e675a2442bb2053ae9"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::getLoop" ref="a7fcbbc51eef313e675a2442bb2053ae9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Loop.html">Loop</a>* <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a7fcbbc51eef313e675a2442bb2053ae9">llvm::SCEVAddRecExpr::getLoop</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00299">299</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>

<p>Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l03173">CollectSubexprs()</a>, <a class="el" href="LoopStrengthReduce_8cpp_source.html#l02422">findIVOperand()</a>, <a class="el" href="IndVarSimplify_8cpp_source.html#l01572">FindLoopCounter()</a>, <a class="el" href="IndVarSimplify_8cpp_source.html#l01655">genLoopLimit()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01970">llvm::ScalarEvolution::getAddExpr()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l02378">llvm::ScalarEvolution::getMulExpr()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l07454">getNumIterationsInRange()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01261">getPreStartForExtend()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00305">getStepRecurrence()</a>, <a class="el" href="LoopStrengthReduce_8cpp_source.html#l00714">isExistingPhi()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l06583">llvm::ScalarEvolution::isKnownPredicate()</a>, <a class="el" href="SimplifyIndVar_8cpp_source.html#l00417">isSimpleIVUser()</a>, <a class="el" href="LoopAccessAnalysis_8cpp_source.html#l00508">llvm::isStridedPtr()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l00142">llvm::SCEV::print()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00688">llvm::SCEVParameterRewriter::visitAddRecExpr()</a>, and <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00784">llvm::SCEVApplyRewriter::visitAddRecExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="a55749fb6ea63e413e3e39645dcc2963c"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::getNumIterationsInRange" ref="a55749fb6ea63e413e3e39645dcc2963c" args="(ConstantRange Range, ScalarEvolution &amp;SE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> * <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a55749fb6ea63e413e3e39645dcc2963c">SCEVAddRecExpr::getNumIterationsInRange</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>getNumIterationsInRange - Return the number of iterations of this loop that produce values in the specified constant range. </p>
<p>Another way of looking at this is that it returns the first iteration number where the value is not in the condition, thus computing the exit count. If the iteration count can't be computed, an instance of <a class="el" href="structllvm_1_1SCEVCouldNotCompute.html" title="SCEVCouldNotCompute - An object of this class is returned by queries that could not be answered...">SCEVCouldNotCompute</a> is returned. </p>

<p>Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07454">7454</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p>References <a class="el" href="ARMBaseInfo_8h_source.html#l00098">llvm::ARM_PROC::A</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00220">llvm::ConstantRange::contains()</a>, <a class="el" href="Casting_8h_source.html#l00285">llvm::dyn_cast()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l05224">EvaluateConstantChrecAtConstant()</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00096">llvm::SCEV::FlagAnyWrap</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00097">llvm::SCEV::FlagNW</a>, <a class="el" href="Constants_8cpp_source.html#l00582">llvm::ConstantInt::get()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l02815">llvm::ScalarEvolution::getAddRecExpr()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l00316">llvm::ScalarEvolution::getConstant()</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00585">llvm::ScalarEvolution::getContext()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l03277">llvm::ScalarEvolution::getCouldNotCompute()</a>, <a class="el" href="Constants_8cpp_source.html#l02072">llvm::ConstantExpr::getICmp()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00299">getLoop()</a>, <a class="el" href="ConstantRange_8h_source.html#l00087">llvm::ConstantRange::getLower()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l03338">llvm::ScalarEvolution::getNegativeSCEV()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00164">llvm::SCEVNAryExpr::getNoWrapFlags()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00148">llvm::SCEVNAryExpr::getNumOperands()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00149">llvm::SCEVNAryExpr::getOperand()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00298">getStart()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00162">llvm::SCEVNAryExpr::getType()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l03256">llvm::ScalarEvolution::getTypeSizeInBits()</a>, <a class="el" href="ConstantRange_8h_source.html#l00091">llvm::ConstantRange::getUpper()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00045">llvm::SCEVConstant::getValue()</a>, <a class="el" href="Constants_8h_source.html#l00105">llvm::ConstantInt::getValue()</a>, <a class="el" href="InstrTypes_8h_source.html#l00718">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00314">isAffine()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00130">llvm::ConstantRange::isFullSet()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00323">isQuadratic()</a>, <a class="el" href="InfiniteTest_8cpp_source.html#l00009">One</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00156">llvm::SCEVNAryExpr::op_begin()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00157">llvm::SCEVNAryExpr::op_end()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00140">llvm::SCEVNAryExpr::Operands</a>, <a class="el" href="PPCISelLowering_8h_source.html#l00276">llvm::PPCISD::SC</a>, <a class="el" href="APInt_8h_source.html#l01133">llvm::APInt::sge()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l06012">SolveQuadraticEquation()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00253">llvm::ConstantRange::subtract()</a>, <a class="el" href="BitVector_8h_source.html#l00576">std::swap()</a>, and <a class="el" href="APInt_8h_source.html#l01851">llvm::APIntOps::udiv()</a>.</p>

</div>
</div>
<a class="anchor" id="ada9969a271c8bab660bfb2aa01f22e76"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::getPostIncExpr" ref="ada9969a271c8bab660bfb2aa01f22e76" args="(ScalarEvolution &amp;SE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a>* <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#ada9969a271c8bab660bfb2aa01f22e76">llvm::SCEVAddRecExpr::getPostIncExpr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;&#160;</td>
          <td class="paramname"><em>SE</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>getPostIncExpr - Return an expression representing the value of this expression one iteration of the loop ahead. </p>

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00351">351</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>

<p>References <a class="el" href="ScalarEvolution_8cpp_source.html#l01970">llvm::ScalarEvolution::getAddExpr()</a>, and <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00305">getStepRecurrence()</a>.</p>

<p>Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l06583">llvm::ScalarEvolution::isKnownPredicate()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d53a749bd858b270d322b34b8d7e1e5"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::getStart" ref="a0d53a749bd858b270d322b34b8d7e1e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a>* <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a0d53a749bd858b270d322b34b8d7e1e5">llvm::SCEVAddRecExpr::getStart</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00298">298</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>

<p>References <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00140">llvm::SCEVNAryExpr::Operands</a>.</p>

<p>Referenced by <a class="el" href="ScalarEvolutionExpander_8cpp_source.html#l00999">canBeCheaplyTransformed()</a>, <a class="el" href="LoopStrengthReduce_8cpp_source.html#l03173">CollectSubexprs()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01067">evaluateAtIteration()</a>, <a class="el" href="IndVarSimplify_8cpp_source.html#l01572">FindLoopCounter()</a>, <a class="el" href="IndVarSimplify_8cpp_source.html#l01655">genLoopLimit()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01970">llvm::ScalarEvolution::getAddExpr()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l07454">getNumIterationsInRange()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01261">getPreStartForExtend()</a>, <a class="el" href="LoopAccessAnalysis_8cpp_source.html#l00115">llvm::LoopAccessInfo::RuntimePointerCheck::insert()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l06583">llvm::ScalarEvolution::isKnownPredicate()</a>.</p>

</div>
</div>
<a class="anchor" id="a443e9130cd9f3e3baaa1b566e6aa5060"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::getStepRecurrence" ref="a443e9130cd9f3e3baaa1b566e6aa5060" args="(ScalarEvolution &amp;SE) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a>* <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a443e9130cd9f3e3baaa1b566e6aa5060">llvm::SCEVAddRecExpr::getStepRecurrence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;&#160;</td>
          <td class="paramname"><em>SE</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>getStepRecurrence - This method constructs and returns the recurrence indicating how much this expression steps by. </p>
<p>If this is a polynomial of degree N, it returns a chrec of degree N-1. We cannot determine whether the step recurrence has self-wraparound. </p>

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00305">305</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>

<p>References <a class="el" href="ScalarEvolution_8h_source.html#l00096">llvm::SCEV::FlagAnyWrap</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l02815">llvm::ScalarEvolution::getAddRecExpr()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00299">getLoop()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00149">llvm::SCEVNAryExpr::getOperand()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00314">isAffine()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00156">llvm::SCEVNAryExpr::op_begin()</a>, and <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00157">llvm::SCEVNAryExpr::op_end()</a>.</p>

<p>Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l03173">CollectSubexprs()</a>, <a class="el" href="IndVarSimplify_8cpp_source.html#l01572">FindLoopCounter()</a>, <a class="el" href="IndVarSimplify_8cpp_source.html#l01655">genLoopLimit()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00351">getPostIncExpr()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01261">getPreStartForExtend()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l04168">getStrideFromPointer()</a>, <a class="el" href="ScalarEvolutionExpander_8cpp_source.html#l01030">IsIncrementNSW()</a>, <a class="el" href="ScalarEvolutionExpander_8cpp_source.html#l01044">IsIncrementNUW()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00455">llvm::isInductionPHI()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l05073">isLikelyComplexAddressComputation()</a>, and <a class="el" href="LoopAccessAnalysis_8cpp_source.html#l00508">llvm::isStridedPtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a88f514461ddb0af0fc59ac4639f644bc"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::isAffine" ref="a88f514461ddb0af0fc59ac4639f644bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a88f514461ddb0af0fc59ac4639f644bc">llvm::SCEVAddRecExpr::isAffine</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isAffine - Return true if this represents an expression A + B*x where A and B are loop invariant values. </p>

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00314">314</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>

<p>References <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00148">llvm::SCEVNAryExpr::getNumOperands()</a>.</p>

<p>Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l07870">computeAccessFunctions()</a>, <a class="el" href="IndVarSimplify_8cpp_source.html#l01572">FindLoopCounter()</a>, <a class="el" href="IndVarSimplify_8cpp_source.html#l01655">genLoopLimit()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l07454">getNumIterationsInRange()</a>, <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00305">getStepRecurrence()</a>, and <a class="el" href="LoopAccessAnalysis_8cpp_source.html#l00289">hasComputableBounds()</a>.</p>

</div>
</div>
<a class="anchor" id="abcef7196d3d3fa9d61a5a2516892c676"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::isQuadratic" ref="abcef7196d3d3fa9d61a5a2516892c676" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#abcef7196d3d3fa9d61a5a2516892c676">llvm::SCEVAddRecExpr::isQuadratic</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isQuadratic - Return true if this represents an expression A + B*x + C*x^2 where A, B and C are loop invariant values. </p>
<p>This corresponds to an addrec of the form {L,+,M,+,N} </p>

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00323">323</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>

<p>References <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00148">llvm::SCEVNAryExpr::getNumOperands()</a>.</p>

<p>Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l07454">getNumIterationsInRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a5316a2763777f3670c1606452f4e99d7"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::setNoWrapFlags" ref="a5316a2763777f3670c1606452f4e99d7" args="(NoWrapFlags Flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classllvm_1_1SCEVAddRecExpr.html#a5316a2763777f3670c1606452f4e99d7">llvm::SCEVAddRecExpr::setNoWrapFlags</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SCEV.html#af43000d4dcb7d6d63cb6e36933ed3f6f">NoWrapFlags</a>&#160;</td>
          <td class="paramname"><em>Flags</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set flags for a recurrence without clearing any previously set flags. </p>
<p>For AddRec, either NUW or NSW implies NW. Keep track of this fact here to make it easier to propagate flags. </p>

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00330">330</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>

<p>References <a class="el" href="ScalarEvolution_8h_source.html#l00099">llvm::SCEV::FlagNSW</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00098">llvm::SCEV::FlagNUW</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00097">llvm::SCEV::FlagNW</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00201">llvm::ScalarEvolution::setFlags()</a>, and <a class="el" href="ScalarEvolution_8h_source.html#l00071">llvm::SCEV::SubclassData</a>.</p>

<p>Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l02833">llvm::ScalarEvolution::getAddRecExpr()</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a15a0237aaba54972c69acad43448c093"></a><!-- doxytag: member="llvm::SCEVAddRecExpr::ScalarEvolution" ref="a15a0237aaba54972c69acad43448c093" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ScalarEvolutionExpressions_8h_source.html#l00289">289</a> of file <a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ScalarEvolutionExpressions_8h_source.html">ScalarEvolutionExpressions.h</a></li>
<li><a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:10:09 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
