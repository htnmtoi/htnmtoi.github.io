<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LLVM: amd_kernel_code_s Struct Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">mainline</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">amd_kernel_code_s Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="amd_kernel_code_s" -->
<p>AMD Kernel Code Object (amd_kernel_code_t).  
 <a href="structamd__kernel__code__s.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for amd_kernel_code_s:</div>
<div class="dyncontent">
<div class="center"><img src="structamd__kernel__code__s__coll__graph.png" border="0" usemap="#amd__kernel__code__s_coll__map" alt="Collaboration graph"/></div>
<map name="amd__kernel__code__s_coll__map" id="amd__kernel__code__s_coll__map">
<area shape="rect" id="node12" href="structhsa__ext__control__directives__s.html" title="The hsa_ext_control_directives_t specifies the values for the HSAIL control directives." alt="" coords="710,527,915,556"/><area shape="rect" id="node18" href="structhsa__dim3__s.html" title="hsa_dim3_s" alt="" coords="486,156,584,185"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="structamd__kernel__code__s-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#ae6f7fe254e2d6abbd59002e212bdb7eb">amd_code_version32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a5bddc8c63b762121016c81d70f17fde3">amd_code_version_major</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The AMD major version of the Code Object.  <a href="#a5bddc8c63b762121016c81d70f17fde3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#ae6f7fe254e2d6abbd59002e212bdb7eb">amd_code_version32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab798002ce56f949174598b0fa73fcb01">amd_code_version_minor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The AMD minor version of the Code Object.  <a href="#ab798002ce56f949174598b0fa73fcb01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a4465bddecaa19438da146926372080b4">struct_byte_size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The byte size of this struct.  <a href="#a4465bddecaa19438da146926372080b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a440703f5808df8f41bca2c862d1d6421">target_chip</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The target chip instruction set for which code has been generated.  <a href="#a440703f5808df8f41bca2c862d1d6421"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab80a7b908b126b9edccb7812d1051e6e">kernel_code_entry_byte_offset</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte offset (possibly negative) from start of amd_kernel_code_t object to kernel's entry point instruction.  <a href="#ab80a7b908b126b9edccb7812d1051e6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a79d19b3dfc497632c6d955628495a1dd">kernel_code_prefetch_byte_offset</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of bytes to consider prefetching expressed as an offset and size.  <a href="#a79d19b3dfc497632c6d955628495a1dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a1fae4434b5596645ae4911169a18ba21">kernel_code_prefetch_byte_size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a252bdcc05ce955c57def16d00c2e0f78">max_scratch_backing_memory_byte_size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes of scratch backing memory required for full occupancy of target chip.  <a href="#a252bdcc05ce955c57def16d00c2e0f78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#a97e20abd21524281734e8e54c450e533">amd_compute_pgm_resource_register64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a7b92859130d65728c35dc29b7edf5636">compute_pgm_resource_registers</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shader program settings for CS.  <a href="#a7b92859130d65728c35dc29b7edf5636"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#aadf1021c85c59f85c7909edff140b35f">amd_code_property32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a3da5e3ea218632e411419e7689b5b06b">code_properties</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Code properties.  <a href="#a3da5e3ea218632e411419e7689b5b06b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a4df57402a4d6bce6adc008a2c2703630">workitem_private_segment_byte_size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of memory required for the combined private, spill and arg segments for a work-item in bytes.  <a href="#a4df57402a4d6bce6adc008a2c2703630"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a76d1342950ad5679cb75e5a551583961">workgroup_group_segment_byte_size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of group segment memory required by a work-group in bytes.  <a href="#a76d1342950ad5679cb75e5a551583961"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab131471b40714a56b941ba224df46401">gds_segment_byte_size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of byte of GDS required by kernel dispatch.  <a href="#ab131471b40714a56b941ba224df46401"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#aa840eff57f443d0ad4f62ddd4d6d9e7f">kernarg_segment_byte_size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size in bytes of the kernarg segment that holds the values of the arguments to the kernel.  <a href="#aa840eff57f443d0ad4f62ddd4d6d9e7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a0fd3b0027b18bfb68447eff86ae369de">workgroup_fbarrier_count</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of fbarrier's used in the kernel and all functions it calls.  <a href="#a0fd3b0027b18bfb68447eff86ae369de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab8ca3407b13af2f0d9a9c80ce582c37b">wavefront_sgpr_count</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of scalar registers used by a wavefront.  <a href="#ab8ca3407b13af2f0d9a9c80ce582c37b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ad6400e51805c0d3e6658f51e0f4b1258">workitem_vgpr_count</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of vector registers used by each work-item.  <a href="#ad6400e51805c0d3e6658f51e0f4b1258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a110a82e27c4c538dd9265a897043f666">reserved_vgpr_first</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If reserved_vgpr_count is 0 then must be 0.  <a href="#a110a82e27c4c538dd9265a897043f666"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a6757964e0e2e4a2f85ea0d3aef282668">reserved_vgpr_count</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of consecutive VGPRs reserved by the client.  <a href="#a6757964e0e2e4a2f85ea0d3aef282668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab3ded9dece15b44ade5de4f64617bbc1">reserved_sgpr_first</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If reserved_sgpr_count is 0 then must be 0.  <a href="#ab3ded9dece15b44ade5de4f64617bbc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab08abdcbd560da11ea18952a8addd07c">reserved_sgpr_count</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of consecutive SGPRs reserved by the client.  <a href="#ab08abdcbd560da11ea18952a8addd07c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a7d620d42712646db99a1161164288821">debug_wavefront_private_segment_offset_sgpr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If is_debug_supported is 0 then must be 0.  <a href="#a7d620d42712646db99a1161164288821"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#af9ab4a23378c0a0447856cab09d99d3b">debug_private_segment_buffer_sgpr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If is_debug_supported is 0 then must be 0.  <a href="#af9ab4a23378c0a0447856cab09d99d3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#a143c7c845aca213614c1d79b65c35a0c">hsa_powertwo8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ad981376d4a30a06e737ec6f22008b0dd">kernarg_segment_alignment</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum byte alignment of variables used by the kernel in the specified memory segment.  <a href="#ad981376d4a30a06e737ec6f22008b0dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#a143c7c845aca213614c1d79b65c35a0c">hsa_powertwo8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a46e395ef4cffe70b299f517442099212">group_segment_alignment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#a143c7c845aca213614c1d79b65c35a0c">hsa_powertwo8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a19e3f9d80056ac50ccc6d3b871c45817">private_segment_alignment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a467a38129c716fe4ad494c263c6a1a28">reserved3</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#aeb2b662521c2d1056eec8dfd45fbb960">hsa_ext_code_kind32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ae03b68109efcb20dccc2ee39e9949c00">code_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of code object.  <a href="#ae03b68109efcb20dccc2ee39e9949c00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a3a177b948f2a9fd74186bc0100992251">reserved4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved for code properties if any are defined in the future.  <a href="#a3a177b948f2a9fd74186bc0100992251"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#a143c7c845aca213614c1d79b65c35a0c">hsa_powertwo8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a84f88789873f265afd0ac24abf0bcd3f">wavefront_size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wavefront size expressed as a power of two.  <a href="#a84f88789873f265afd0ac24abf0bcd3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a03dddf19229449e00f9e3a0a9a3cb3c0">optimization_level</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimization level specified when the kernel was finalized.  <a href="#a03dddf19229449e00f9e3a0a9a3cb3c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#a4d058e43da41c147915dbe70cace9947">hsa_ext_brig_profile8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a749eabb630c5bf332894140ca5416db0">hsail_profile</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The HSAIL profile defines which features are used.  <a href="#a749eabb630c5bf332894140ca5416db0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#a5030b76e1c72556f42a7dc7eebab16df">hsa_ext_brig_machine_model8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ac0ba5a5990ccb66c1bced5e72eb19952">hsail_machine_model</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The HSAIL machine model gives the address sizes used by the code.  <a href="#ac0ba5a5990ccb66c1bced5e72eb19952"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a8249273a0cb93d5b2b356d78dc46ffd9">hsail_version_major</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The HSAIL major version.  <a href="#a8249273a0cb93d5b2b356d78dc46ffd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a94eb2fb402ff86e092cfc08b70cfabdb">hsail_version_minor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The HSAIL minor version.  <a href="#a94eb2fb402ff86e092cfc08b70cfabdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a8c1c423e8ee33bded8076fa23c5e1c7a">reserved5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved for HSAIL target options if any are defined in the future.  <a href="#a8c1c423e8ee33bded8076fa23c5e1c7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#acaf237866c9d098817f9606e4cb4876e">reserved6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved. Must be 0.  <a href="#acaf237866c9d098817f9606e4cb4876e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AMDKernelCodeT_8h.html#a40c83573be6c1e21ad46ff8a7edd21b0">hsa_ext_control_directives_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a14ed8deebf5868a79fa3db7bacf34157">control_directive</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The values should be the actually values used by the finalizer in generating the code.  <a href="#a14ed8deebf5868a79fa3db7bacf34157"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>AMD Kernel Code Object (amd_kernel_code_t). </p>
<p>GPU CP uses the AMD Kernel Code Object to set up the hardware to execute the kernel dispatch.</p>
<p>Initial Kernel Register State.</p>
<p>Initial kernel register state will be set up by CP/SPI prior to the start of execution of every wavefront. This is limited by the constraints of the current hardware.</p>
<p>The order of the SGPR registers is defined, but the Finalizer can specify which ones are actually setup in the amd_kernel_code_t object using the enable_sgpr_* bit fields. The register numbers used for enabled registers are dense starting at SGPR0: the first enabled register is SGPR0, the next enabled register is SGPR1 etc.; disabled registers do not have an SGPR number.</p>
<p>The initial SGPRs comprise up to 16 User SRGPs that are set up by CP and apply to all waves of the grid. It is possible to specify more than 16 User SGPRs using the enable_sgpr_* bit fields, in which case only the first 16 are actually initialized. These are then immediately followed by the System SGPRs that are set up by ADC/SPI and can have different values for each wave of the grid dispatch.</p>
<p>SGPR register initial state is defined as follows:</p>
<p>Private Segment Buffer (enable_sgpr_private_segment_buffer): Number of User SGPR registers: 4. V# that can be used, together with Scratch Wave Offset as an offset, to access the Private/Spill/Arg segments using a segment address. It must be set as follows:</p>
<ul>
<li>Base address: of the scratch memory area used by the dispatch. It does not include the scratch wave offset. It will be the per process SH_HIDDEN_PRIVATE_BASE_VMID plus any offset from this dispatch (for example there may be a per pipe offset, or per AQL Queue offset).</li>
<li>Stride + data_format: Element Size * Index Stride (???)</li>
<li>Cache swizzle: ???</li>
<li>Swizzle enable: SH_STATIC_MEM_CONFIG.SWIZZLE_ENABLE (must be 1 for scratch)</li>
<li>Num records: Flat Scratch Work Item Size / Element Size (???)</li>
<li>Dst_sel_*: ???</li>
<li>Num_format: ???</li>
<li>Element_size: SH_STATIC_MEM_CONFIG.ELEMENT_SIZE (will be DWORD, must agree with amd_kernel_code_t.privateElementSize)</li>
<li>Index_stride: SH_STATIC_MEM_CONFIG.INDEX_STRIDE (will be 64 as must be number of wavefront lanes for scratch, must agree with amd_kernel_code_t.wavefrontSize)</li>
<li>Add tid enable: 1</li>
<li>ATC: from SH_MEM_CONFIG.PRIVATE_ATC,</li>
<li>Hash_enable: ???</li>
<li>Heap: ???</li>
<li>Mtype: from SH_STATIC_MEM_CONFIG.PRIVATE_MTYPE</li>
<li>Type: 0 (a buffer) (???)</li>
</ul>
<p>Dispatch Ptr (enable_sgpr_dispatch_ptr): Number of User SGPR registers: 2. 64 bit address of AQL dispatch packet for kernel actually executing.</p>
<p>Queue Ptr (enable_sgpr_queue_ptr): Number of User SGPR registers: 2. 64 bit address of AmdQueue object for AQL queue on which the dispatch packet was queued.</p>
<p>Kernarg Segment Ptr (enable_sgpr_kernarg_segment_ptr): Number of User SGPR registers: 2. 64 bit address of Kernarg segment. This is directly copied from the kernargPtr in the dispatch packet. Having CP load it once avoids loading it at the beginning of every wavefront.</p>
<p>Dispatch Id (enable_sgpr_dispatch_id): Number of User SGPR registers: 2. 64 bit Dispatch ID of the dispatch packet being executed.</p>
<p>Flat Scratch Init (enable_sgpr_flat_scratch_init): Number of User SGPR registers: 2. This is 2 SGPRs.</p>
<p>For CI/VI: The first SGPR is a 32 bit byte offset from SH_MEM_HIDDEN_PRIVATE_BASE to base of memory for scratch for this dispatch. This is the same offset used in computing the Scratch Segment Buffer base address. The value of Scratch Wave Offset must be added by the kernel code and moved to SGPRn-4 for use as the FLAT SCRATCH BASE in flat memory instructions.</p>
<p>The second SGPR is 32 bit byte size of a single work-item’s scratch memory usage. This is directly loaded from the dispatch packet Private Segment Byte Size and rounded up to a multiple of DWORD.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>[Does CP need to round this to &gt;4 byte alignment?]</dd></dl>
<p>The kernel code must move to SGPRn-3 for use as the FLAT SCRATCH SIZE in flat memory instructions. Having CP load it once avoids loading it at the beginning of every wavefront.</p>
<p>For PI: This is the 64 bit base address of the scratch backing memory for allocated by CP for this dispatch.</p>
<p>Private Segment Size (enable_sgpr_private_segment_size): Number of User SGPR registers: 1. The 32 bit byte size of a single work-item’s scratch memory allocation. This is the value from the dispatch packet. Private Segment Byte Size rounded up by CP to a multiple of DWORD.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>[Does CP need to round this to &gt;4 byte alignment?]</dd></dl>
<p>Having CP load it once avoids loading it at the beginning of every wavefront.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>[This will not be used for CI/VI since it is the same value as the second SGPR of Flat Scratch Init. However, it is need for PI which changes meaning of Flat Scratchg Init..]</dd></dl>
<p>Grid Work-Group Count X (enable_sgpr_grid_workgroup_count_x): Number of User SGPR registers: 1. 32 bit count of the number of work-groups in the X dimension for the grid being executed. Computed from the fields in the HsaDispatchPacket as ((gridSize.x+workgroupSize.x-1)/workgroupSize.x).</p>
<p>Grid Work-Group Count Y (enable_sgpr_grid_workgroup_count_y): Number of User SGPR registers: 1. 32 bit count of the number of work-groups in the Y dimension for the grid being executed. Computed from the fields in the HsaDispatchPacket as ((gridSize.y+workgroupSize.y-1)/workgroupSize.y).</p>
<p>Only initialized if &lt;16 previous SGPRs initialized.</p>
<p>Grid Work-Group Count Z (enable_sgpr_grid_workgroup_count_z): Number of User SGPR registers: 1. 32 bit count of the number of work-groups in the Z dimension for the grid being executed. Computed from the fields in the HsaDispatchPacket as ((gridSize.z+workgroupSize.z-1)/workgroupSize.z).</p>
<p>Only initialized if &lt;16 previous SGPRs initialized.</p>
<p>Work-Group Id X (enable_sgpr_workgroup_id_x): Number of System SGPR registers: 1. 32 bit work group id in X dimension of grid for wavefront. Always present.</p>
<p>Work-Group Id Y (enable_sgpr_workgroup_id_y): Number of System SGPR registers: 1. 32 bit work group id in Y dimension of grid for wavefront.</p>
<p>Work-Group Id Z (enable_sgpr_workgroup_id_z): Number of System SGPR registers: 1. 32 bit work group id in Z dimension of grid for wavefront. If present then Work-group Id Y will also be present</p>
<p>Work-Group Info (enable_sgpr_workgroup_info): Number of System SGPR registers: 1. {first_wave, 14’b0000, ordered_append_term[10:0], threadgroup_size_in_waves[5:0]}</p>
<p>Private Segment Wave Byte Offset (enable_sgpr_private_segment_wave_byte_offset): Number of System SGPR registers: 1. 32 bit byte offset from base of dispatch scratch base. Must be used as an offset with Private/Spill/Arg segment address when using Scratch Segment Buffer. It must be added to Flat Scratch Offset if setting up FLAT SCRATCH for flat addressing.</p>
<p>The order of the VGPR registers is defined, but the Finalizer can specify which ones are actually setup in the amd_kernel_code_t object using the enableVgpr* bit fields. The register numbers used for enabled registers are dense starting at VGPR0: the first enabled register is VGPR0, the next enabled register is VGPR1 etc.; disabled registers do not have an VGPR number.</p>
<p>VGPR register initial state is defined as follows:</p>
<p>Work-Item Id X (always initialized): Number of registers: 1. 32 bit work item id in X dimension of work-group for wavefront lane.</p>
<p>Work-Item Id X (enable_vgpr_workitem_id &gt; 0): Number of registers: 1. 32 bit work item id in Y dimension of work-group for wavefront lane.</p>
<p>Work-Item Id X (enable_vgpr_workitem_id &gt; 0): Number of registers: 1. 32 bit work item id in Z dimension of work-group for wavefront lane.</p>
<p>The setting of registers is being done by existing GPU hardware as follows: 1) SGPRs before the Work-Group Ids are set by CP using the 16 User Data registers. 2) Work-group Id registers X, Y, Z are set by SPI which supports any combination including none. 3) Scratch Wave Offset is also set by SPI which is why its value cannot be added into the value Flat Scratch Offset which would avoid the Finalizer generated prolog having to do the add. 4) The VGPRs are set by SPI which only supports specifying either (X), (X, Y) or (X, Y, Z).</p>
<p>Flat Scratch Dispatch Offset and Flat Scratch Size are adjacent SGRRs so they can be moved as a 64 bit value to the hardware required SGPRn-3 and SGPRn-4 respectively using the Finalizer ?FLAT_SCRATCH? Register.</p>
<p>The global segment can be accessed either using flat operations or buffer operations. If buffer operations are used then the Global Buffer used to access HSAIL Global/Readonly/Kernarg (which are combine) segments using a segment address is not passed into the kernel code by CP since its base address is always 0. Instead the Finalizer generates prolog code to initialize 4 SGPRs with a V# that has the following properties, and then uses that in the buffer instructions:</p>
<ul>
<li>base address of 0</li>
<li>no swizzle</li>
<li>ATC=1</li>
<li>MTYPE set to support memory coherence specified in amd_kernel_code_t.globalMemoryCoherence</li>
</ul>
<p>When the Global Buffer is used to access the Kernarg segment, must add the dispatch packet kernArgPtr to a kernarg segment address before using this V#. Alternatively scalar loads can be used if the kernarg offset is uniform, as the kernarg segment is constant for the duration of the kernel execution. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00502">502</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>
</div><hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a5bddc8c63b762121016c81d70f17fde3"></a><!-- doxytag: member="amd_kernel_code_s::amd_code_version_major" ref="a5bddc8c63b762121016c81d70f17fde3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#ae6f7fe254e2d6abbd59002e212bdb7eb">amd_code_version32_t</a> <a class="el" href="structamd__kernel__code__s.html#a5bddc8c63b762121016c81d70f17fde3">amd_kernel_code_s::amd_code_version_major</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The AMD major version of the Code Object. </p>
<p>Must be the value AMD_CODE_VERSION_MAJOR. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00505">505</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab798002ce56f949174598b0fa73fcb01"></a><!-- doxytag: member="amd_kernel_code_s::amd_code_version_minor" ref="ab798002ce56f949174598b0fa73fcb01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#ae6f7fe254e2d6abbd59002e212bdb7eb">amd_code_version32_t</a> <a class="el" href="structamd__kernel__code__s.html#ab798002ce56f949174598b0fa73fcb01">amd_kernel_code_s::amd_code_version_minor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The AMD minor version of the Code Object. </p>
<p>Minor versions must be backward compatible. Must be the value AMD_CODE_VERSION_MINOR. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00510">510</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3da5e3ea218632e411419e7689b5b06b"></a><!-- doxytag: member="amd_kernel_code_s::code_properties" ref="a3da5e3ea218632e411419e7689b5b06b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#aadf1021c85c59f85c7909edff140b35f">amd_code_property32_t</a> <a class="el" href="structamd__kernel__code__s.html#a3da5e3ea218632e411419e7689b5b06b">amd_kernel_code_s::code_properties</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Code properties. </p>
<p>See amd_code_property_mask_t for a full list of properties. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00560">560</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae03b68109efcb20dccc2ee39e9949c00"></a><!-- doxytag: member="amd_kernel_code_s::code_type" ref="ae03b68109efcb20dccc2ee39e9949c00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#aeb2b662521c2d1056eec8dfd45fbb960">hsa_ext_code_kind32_t</a> <a class="el" href="structamd__kernel__code__s.html#ae03b68109efcb20dccc2ee39e9949c00">amd_kernel_code_s::code_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of code object. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00639">639</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b92859130d65728c35dc29b7edf5636"></a><!-- doxytag: member="amd_kernel_code_s::compute_pgm_resource_registers" ref="a7b92859130d65728c35dc29b7edf5636" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#a97e20abd21524281734e8e54c450e533">amd_compute_pgm_resource_register64_t</a> <a class="el" href="structamd__kernel__code__s.html#a7b92859130d65728c35dc29b7edf5636">amd_kernel_code_s::compute_pgm_resource_registers</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shader program settings for CS. </p>
<p>Contains COMPUTE_PGM_RSRC1 and COMPUTE_PGM_RSRC2 registers. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00556">556</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a14ed8deebf5868a79fa3db7bacf34157"></a><!-- doxytag: member="amd_kernel_code_s::control_directive" ref="a14ed8deebf5868a79fa3db7bacf34157" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#a40c83573be6c1e21ad46ff8a7edd21b0">hsa_ext_control_directives_t</a> <a class="el" href="structamd__kernel__code__s.html#a14ed8deebf5868a79fa3db7bacf34157">amd_kernel_code_s::control_directive</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The values should be the actually values used by the finalizer in generating the code. </p>
<p>This may be the union of values specified as finalizer arguments and explicit HSAIL control directives. If the finalizer chooses to ignore a control directive, and not generate constrained code, then the control directive should not be marked as enabled even though it was present in the HSAIL or finalizer argument. The values are intended to reflect the constraints that the code actually requires to correctly execute, not the values that were actually specified at finalize time. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00696">696</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9ab4a23378c0a0447856cab09d99d3b"></a><!-- doxytag: member="amd_kernel_code_s::debug_private_segment_buffer_sgpr" ref="af9ab4a23378c0a0447856cab09d99d3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#af9ab4a23378c0a0447856cab09d99d3b">amd_kernel_code_s::debug_private_segment_buffer_sgpr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If is_debug_supported is 0 then must be 0. </p>
<p>Otherwise, this is the fixed SGPR number of the first of 4 SGPRs used to hold the scratch V# used for the entire kernel execution, or uint16_t(-1) if the registers are not used or not known. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00627">627</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d620d42712646db99a1161164288821"></a><!-- doxytag: member="amd_kernel_code_s::debug_wavefront_private_segment_offset_sgpr" ref="a7d620d42712646db99a1161164288821" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#a7d620d42712646db99a1161164288821">amd_kernel_code_s::debug_wavefront_private_segment_offset_sgpr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If is_debug_supported is 0 then must be 0. </p>
<p>Otherwise, this is the fixed SGPR number used to hold the wave scratch offset for the entire kernel execution, or uint16_t(-1) if the register is not used or not known. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00621">621</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab131471b40714a56b941ba224df46401"></a><!-- doxytag: member="amd_kernel_code_s::gds_segment_byte_size" ref="ab131471b40714a56b941ba224df46401" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="structamd__kernel__code__s.html#ab131471b40714a56b941ba224df46401">amd_kernel_code_s::gds_segment_byte_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of byte of GDS required by kernel dispatch. </p>
<p>Must be 0 if not using GDS. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00576">576</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a46e395ef4cffe70b299f517442099212"></a><!-- doxytag: member="amd_kernel_code_s::group_segment_alignment" ref="a46e395ef4cffe70b299f517442099212" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#a143c7c845aca213614c1d79b65c35a0c">hsa_powertwo8_t</a> <a class="el" href="structamd__kernel__code__s.html#a46e395ef4cffe70b299f517442099212">amd_kernel_code_s::group_segment_alignment</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00633">633</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac0ba5a5990ccb66c1bced5e72eb19952"></a><!-- doxytag: member="amd_kernel_code_s::hsail_machine_model" ref="ac0ba5a5990ccb66c1bced5e72eb19952" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#a5030b76e1c72556f42a7dc7eebab16df">hsa_ext_brig_machine_model8_t</a> <a class="el" href="structamd__kernel__code__s.html#ac0ba5a5990ccb66c1bced5e72eb19952">amd_kernel_code_s::hsail_machine_model</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The HSAIL machine model gives the address sizes used by the code. </p>
<p>This information is from the HSAIL version directive. If not generated from an HSAIL compilation unit then must still indicate for what machine mode the code is generated. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00666">666</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a749eabb630c5bf332894140ca5416db0"></a><!-- doxytag: member="amd_kernel_code_s::hsail_profile" ref="a749eabb630c5bf332894140ca5416db0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#a4d058e43da41c147915dbe70cace9947">hsa_ext_brig_profile8_t</a> <a class="el" href="structamd__kernel__code__s.html#a749eabb630c5bf332894140ca5416db0">amd_kernel_code_s::hsail_profile</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The HSAIL profile defines which features are used. </p>
<p>This information is from the HSAIL version directive. If this amd_kernel_code_t is not generated from an HSAIL compilation unit then must be 0. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00660">660</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8249273a0cb93d5b2b356d78dc46ffd9"></a><!-- doxytag: member="amd_kernel_code_s::hsail_version_major" ref="a8249273a0cb93d5b2b356d78dc46ffd9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="structamd__kernel__code__s.html#a8249273a0cb93d5b2b356d78dc46ffd9">amd_kernel_code_s::hsail_version_major</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The HSAIL major version. </p>
<p>This information is from the HSAIL version directive. If this amd_kernel_code_t is not generated from an HSAIL compilation unit then must be 0. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00671">671</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a94eb2fb402ff86e092cfc08b70cfabdb"></a><!-- doxytag: member="amd_kernel_code_s::hsail_version_minor" ref="a94eb2fb402ff86e092cfc08b70cfabdb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="structamd__kernel__code__s.html#a94eb2fb402ff86e092cfc08b70cfabdb">amd_kernel_code_s::hsail_version_minor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The HSAIL minor version. </p>
<p>This information is from the HSAIL version directive. If this amd_kernel_code_t is not generated from an HSAIL compilation unit then must be 0. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00676">676</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad981376d4a30a06e737ec6f22008b0dd"></a><!-- doxytag: member="amd_kernel_code_s::kernarg_segment_alignment" ref="ad981376d4a30a06e737ec6f22008b0dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#a143c7c845aca213614c1d79b65c35a0c">hsa_powertwo8_t</a> <a class="el" href="structamd__kernel__code__s.html#ad981376d4a30a06e737ec6f22008b0dd">amd_kernel_code_s::kernarg_segment_alignment</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum byte alignment of variables used by the kernel in the specified memory segment. </p>
<p>Expressed as a power of two. Must be at least HSA_POWERTWO_16. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00632">632</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa840eff57f443d0ad4f62ddd4d6d9e7f"></a><!-- doxytag: member="amd_kernel_code_s::kernarg_segment_byte_size" ref="aa840eff57f443d0ad4f62ddd4d6d9e7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="structamd__kernel__code__s.html#aa840eff57f443d0ad4f62ddd4d6d9e7f">amd_kernel_code_s::kernarg_segment_byte_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size in bytes of the kernarg segment that holds the values of the arguments to the kernel. </p>
<p>This could be used by CP to prefetch the kernarg segment pointed to by the dispatch packet. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00581">581</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab80a7b908b126b9edccb7812d1051e6e"></a><!-- doxytag: member="amd_kernel_code_s::kernel_code_entry_byte_offset" ref="ab80a7b908b126b9edccb7812d1051e6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="structamd__kernel__code__s.html#ab80a7b908b126b9edccb7812d1051e6e">amd_kernel_code_s::kernel_code_entry_byte_offset</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Byte offset (possibly negative) from start of amd_kernel_code_t object to kernel's entry point instruction. </p>
<p>The actual code for the kernel is required to be 256 byte aligned to match hardware requirements (SQ cache line is 16). The code must be position independent code (PIC) for AMD devices to give runtime the option of copying code to discrete GPU memory or APU L2 cache. The Finalizer should endeavour to allocate all kernel machine code in contiguous memory pages so that a device pre-fetcher will tend to only pre-fetch Kernel Code objects, improving cache performance. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00532">532</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a79d19b3dfc497632c6d955628495a1dd"></a><!-- doxytag: member="amd_kernel_code_s::kernel_code_prefetch_byte_offset" ref="a79d19b3dfc497632c6d955628495a1dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="structamd__kernel__code__s.html#a79d19b3dfc497632c6d955628495a1dd">amd_kernel_code_s::kernel_code_prefetch_byte_offset</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Range of bytes to consider prefetching expressed as an offset and size. </p>
<p>The offset is from the start (possibly negative) of amd_kernel_code_t object. Set both to 0 if no prefetch information is available.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>ttye 11/15/2013 Is the prefetch definition we want? Did not make the size a uint64_t as prefetching more than 4GiB seems excessive. </dd></dl>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00542">542</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1fae4434b5596645ae4911169a18ba21"></a><!-- doxytag: member="amd_kernel_code_s::kernel_code_prefetch_byte_size" ref="a1fae4434b5596645ae4911169a18ba21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="structamd__kernel__code__s.html#a1fae4434b5596645ae4911169a18ba21">amd_kernel_code_s::kernel_code_prefetch_byte_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00543">543</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a252bdcc05ce955c57def16d00c2e0f78"></a><!-- doxytag: member="amd_kernel_code_s::max_scratch_backing_memory_byte_size" ref="a252bdcc05ce955c57def16d00c2e0f78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="structamd__kernel__code__s.html#a252bdcc05ce955c57def16d00c2e0f78">amd_kernel_code_s::max_scratch_backing_memory_byte_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of bytes of scratch backing memory required for full occupancy of target chip. </p>
<p>This takes into account the number of bytes of scratch per work-item, the wavefront size, the maximum number of wavefronts per <a class="el" href="namespaceCU.html">CU</a>, and the number of CUs. This is an upper limit on scratch. If the grid being dispatched is small it may only need less than this. If the kernel uses no scratch, or the Finalizer has not computed this value, it must be 0. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00552">552</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a03dddf19229449e00f9e3a0a9a3cb3c0"></a><!-- doxytag: member="amd_kernel_code_s::optimization_level" ref="a03dddf19229449e00f9e3a0a9a3cb3c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="structamd__kernel__code__s.html#a03dddf19229449e00f9e3a0a9a3cb3c0">amd_kernel_code_s::optimization_level</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The optimization level specified when the kernel was finalized. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00654">654</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19e3f9d80056ac50ccc6d3b871c45817"></a><!-- doxytag: member="amd_kernel_code_s::private_segment_alignment" ref="a19e3f9d80056ac50ccc6d3b871c45817" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#a143c7c845aca213614c1d79b65c35a0c">hsa_powertwo8_t</a> <a class="el" href="structamd__kernel__code__s.html#a19e3f9d80056ac50ccc6d3b871c45817">amd_kernel_code_s::private_segment_alignment</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00634">634</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a467a38129c716fe4ad494c263c6a1a28"></a><!-- doxytag: member="amd_kernel_code_s::reserved3" ref="a467a38129c716fe4ad494c263c6a1a28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="structamd__kernel__code__s.html#a467a38129c716fe4ad494c263c6a1a28">amd_kernel_code_s::reserved3</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00636">636</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3a177b948f2a9fd74186bc0100992251"></a><!-- doxytag: member="amd_kernel_code_s::reserved4" ref="a3a177b948f2a9fd74186bc0100992251" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="structamd__kernel__code__s.html#a3a177b948f2a9fd74186bc0100992251">amd_kernel_code_s::reserved4</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reserved for code properties if any are defined in the future. </p>
<p>There are currently no code properties so this field must be 0. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00643">643</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8c1c423e8ee33bded8076fa23c5e1c7a"></a><!-- doxytag: member="amd_kernel_code_s::reserved5" ref="a8c1c423e8ee33bded8076fa23c5e1c7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#a8c1c423e8ee33bded8076fa23c5e1c7a">amd_kernel_code_s::reserved5</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reserved for HSAIL target options if any are defined in the future. </p>
<p>There are currently no target options so this field must be 0. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00681">681</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="acaf237866c9d098817f9606e4cb4876e"></a><!-- doxytag: member="amd_kernel_code_s::reserved6" ref="acaf237866c9d098817f9606e4cb4876e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#acaf237866c9d098817f9606e4cb4876e">amd_kernel_code_s::reserved6</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reserved. Must be 0. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00684">684</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab08abdcbd560da11ea18952a8addd07c"></a><!-- doxytag: member="amd_kernel_code_s::reserved_sgpr_count" ref="ab08abdcbd560da11ea18952a8addd07c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#ab08abdcbd560da11ea18952a8addd07c">amd_kernel_code_s::reserved_sgpr_count</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of consecutive SGPRs reserved by the client. </p>
<p>If is_debug_supported then this count includes SGPRs reserved for debugger use. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00615">615</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab3ded9dece15b44ade5de4f64617bbc1"></a><!-- doxytag: member="amd_kernel_code_s::reserved_sgpr_first" ref="ab3ded9dece15b44ade5de4f64617bbc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#ab3ded9dece15b44ade5de4f64617bbc1">amd_kernel_code_s::reserved_sgpr_first</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If reserved_sgpr_count is 0 then must be 0. </p>
<p>Otherwise, this is the first fixed SGPR number reserved. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00610">610</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6757964e0e2e4a2f85ea0d3aef282668"></a><!-- doxytag: member="amd_kernel_code_s::reserved_vgpr_count" ref="a6757964e0e2e4a2f85ea0d3aef282668" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#a6757964e0e2e4a2f85ea0d3aef282668">amd_kernel_code_s::reserved_vgpr_count</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of consecutive VGPRs reserved by the client. </p>
<p>If is_debug_supported then this count includes VGPRs reserved for debugger use. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00606">606</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a110a82e27c4c538dd9265a897043f666"></a><!-- doxytag: member="amd_kernel_code_s::reserved_vgpr_first" ref="a110a82e27c4c538dd9265a897043f666" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#a110a82e27c4c538dd9265a897043f666">amd_kernel_code_s::reserved_vgpr_first</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If reserved_vgpr_count is 0 then must be 0. </p>
<p>Otherwise, this is the first fixed VGPR number reserved. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00601">601</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4465bddecaa19438da146926372080b4"></a><!-- doxytag: member="amd_kernel_code_s::struct_byte_size" ref="a4465bddecaa19438da146926372080b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="structamd__kernel__code__s.html#a4465bddecaa19438da146926372080b4">amd_kernel_code_s::struct_byte_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The byte size of this struct. </p>
<p>Must be set to sizeof(amd_kernel_code_t). Used for backward compatibility. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00515">515</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a440703f5808df8f41bca2c862d1d6421"></a><!-- doxytag: member="amd_kernel_code_s::target_chip" ref="a440703f5808df8f41bca2c862d1d6421" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="structamd__kernel__code__s.html#a440703f5808df8f41bca2c862d1d6421">amd_kernel_code_s::target_chip</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The target chip instruction set for which code has been generated. </p>
<p>Values are from the E_SC_INSTRUCTION_SET enumeration in sc/Interface/SCCommon.h. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00520">520</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab8ca3407b13af2f0d9a9c80ce582c37b"></a><!-- doxytag: member="amd_kernel_code_s::wavefront_sgpr_count" ref="ab8ca3407b13af2f0d9a9c80ce582c37b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#ab8ca3407b13af2f0d9a9c80ce582c37b">amd_kernel_code_s::wavefront_sgpr_count</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of scalar registers used by a wavefront. </p>
<p>This includes the special SGPRs for VCC, Flat Scratch Base, Flat Scratch Size and XNACK (for GFX8 (VI)). It does not include the 16 SGPR added if a trap handler is enabled. Used to set COMPUTE_PGM_RSRC1.SGPRS. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00593">593</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a84f88789873f265afd0ac24abf0bcd3f"></a><!-- doxytag: member="amd_kernel_code_s::wavefront_size" ref="a84f88789873f265afd0ac24abf0bcd3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMDKernelCodeT_8h.html#a143c7c845aca213614c1d79b65c35a0c">hsa_powertwo8_t</a> <a class="el" href="structamd__kernel__code__s.html#a84f88789873f265afd0ac24abf0bcd3f">amd_kernel_code_s::wavefront_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wavefront size expressed as a power of two. </p>
<p>Must be a power of 2 in range 1..64 inclusive. Used to support runtime query that obtains wavefront size, which may be used by application to allocated dynamic group memory and set the dispatch work-group size. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00650">650</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0fd3b0027b18bfb68447eff86ae369de"></a><!-- doxytag: member="amd_kernel_code_s::workgroup_fbarrier_count" ref="a0fd3b0027b18bfb68447eff86ae369de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="structamd__kernel__code__s.html#a0fd3b0027b18bfb68447eff86ae369de">amd_kernel_code_s::workgroup_fbarrier_count</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of fbarrier's used in the kernel and all functions it calls. </p>
<p>If the implementation uses group memory to allocate the fbarriers then that amount must already be included in the workgroup_group_segment_byte_size total. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00587">587</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a76d1342950ad5679cb75e5a551583961"></a><!-- doxytag: member="amd_kernel_code_s::workgroup_group_segment_byte_size" ref="a76d1342950ad5679cb75e5a551583961" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="structamd__kernel__code__s.html#a76d1342950ad5679cb75e5a551583961">amd_kernel_code_s::workgroup_group_segment_byte_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The amount of group segment memory required by a work-group in bytes. </p>
<p>This does not include any dynamically allocated group segment memory that may be added when the kernel is dispatched. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00572">572</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4df57402a4d6bce6adc008a2c2703630"></a><!-- doxytag: member="amd_kernel_code_s::workitem_private_segment_byte_size" ref="a4df57402a4d6bce6adc008a2c2703630" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="structamd__kernel__code__s.html#a4df57402a4d6bce6adc008a2c2703630">amd_kernel_code_s::workitem_private_segment_byte_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The amount of memory required for the combined private, spill and arg segments for a work-item in bytes. </p>
<p>If is_dynamic_callstack is 1 then additional space must be added to this value for the call stack. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00566">566</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad6400e51805c0d3e6658f51e0f4b1258"></a><!-- doxytag: member="amd_kernel_code_s::workitem_vgpr_count" ref="ad6400e51805c0d3e6658f51e0f4b1258" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="structamd__kernel__code__s.html#ad6400e51805c0d3e6658f51e0f4b1258">amd_kernel_code_s::workitem_vgpr_count</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of vector registers used by each work-item. </p>
<p>Used to set COMPUTE_PGM_RSRC1.VGPRS. </p>

<p>Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00597">597</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 03:59:53 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
