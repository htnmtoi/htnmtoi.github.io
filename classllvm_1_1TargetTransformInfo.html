<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LLVM: llvm::TargetTransformInfo Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">mainline</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacellvm.html">llvm</a>      </li>
      <li class="navelem"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">llvm::TargetTransformInfo Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="llvm::TargetTransformInfo" -->
<p>This pass provides access to the codegen interfaces that are needed for IR-level transformations.  
 <a href="classllvm_1_1TargetTransformInfo.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>&gt;</code></p>

<p><a href="classllvm_1_1TargetTransformInfo-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html">UnrollingPreferences</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters that control the generic loop unrolling transformation.  <a href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#af1bf12b2f33b7e30f8f361a1e7642079">TargetTransformInfo</a> (<a class="el" href="classT.html">T</a> Impl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a TTI object using a type implementing the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below.  <a href="#af1bf12b2f33b7e30f8f361a1e7642079"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a68bb8cdc73630ccd03ca7998503865d1">TargetTransformInfo</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> *<a class="el" href="namespacellvm.html#a488b094cb42981f433eaefd848483445af05187141351f049a0f829e8922de7d8">DL</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a baseline TTI object using a minimal implementation of the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below.  <a href="#a68bb8cdc73630ccd03ca7998503865d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ab158463a734f57c86e685364527ebaa4">TargetTransformInfo</a> (<a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;Arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a6d955ca0eda3479b562ccc505575049b">operator=</a> (<a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;RHS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#af9e9d106cef4491370c43c4f136fc050">~TargetTransformInfo</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a4ae49cc86eae7758dfb1d039b7e35614">invalidate</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1PreservedAnalyses.html">PreservedAnalyses</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the invalidation of this information.  <a href="#a4ae49cc86eae7758dfb1d039b7e35614"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Generic Target Information</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ac44f6b9fdbb5f9cc199f8329cb0b272c">TargetCostConstants</a> { <a class="el" href="classllvm_1_1TargetTransformInfo.html#ac44f6b9fdbb5f9cc199f8329cb0b272ca89f768b1267e3083b4eb05b4ab77e717">TCC_Free</a> =  0, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#ac44f6b9fdbb5f9cc199f8329cb0b272cae46c9eecc49bd2dc253c607e78a0fb86">TCC_Basic</a> =  1, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#ac44f6b9fdbb5f9cc199f8329cb0b272ca022565d444ccf496c0414bccefbcd9c8">TCC_Expensive</a> =  4
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying constants for 'cost' values in this interface.  <a href="classllvm_1_1TargetTransformInfo.html#ac44f6b9fdbb5f9cc199f8329cb0b272c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a65495ba8e884cf7cd52e6651b78d4517">getOperationCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1Type.html">Type</a> *OpTy=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of a specific operation when lowered.  <a href="#a65495ba8e884cf7cd52e6651b78d4517"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#abceb0d7d889b22a0ba068f809bd0479b">getGEPCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; <a class="el" href="SIFoldOperands_8cpp.html#ab8aa78e8f3df83c283f0a822be7a7792">Operands</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of a GEP operation when lowered.  <a href="#abceb0d7d889b22a0ba068f809bd0479b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ac57143b0af7b0b64eac63f2898c3b83e">getCallCost</a> (<a class="el" href="classllvm_1_1FunctionType.html">FunctionType</a> *FTy, <a class="el" href="classint.html">int</a> NumArgs=-1) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of a function call when lowered.  <a href="#ac57143b0af7b0b64eac63f2898c3b83e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a38259cfb42552b62e29800357fb19615">getCallCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a>, <a class="el" href="classint.html">int</a> NumArgs=-1) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of calling a specific function when lowered.  <a href="#a38259cfb42552b62e29800357fb19615"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ab8520bbb6695a8f502dc7d800efe44c3">getCallCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; Arguments) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of calling a specific function when lowered.  <a href="#ab8520bbb6695a8f502dc7d800efe44c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ada3b0313ffc99f47c742434ef58e9028">getIntrinsicCost</a> (<a class="el" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90">Intrinsic::ID</a> IID, <a class="el" href="classllvm_1_1Type.html">Type</a> *RetTy, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; ParamTys) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of an intrinsic when lowered.  <a href="#ada3b0313ffc99f47c742434ef58e9028"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#aa9d36b0d23c5c6f49b6d103ebd1d9d2b">getIntrinsicCost</a> (<a class="el" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90">Intrinsic::ID</a> IID, <a class="el" href="classllvm_1_1Type.html">Type</a> *RetTy, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; Arguments) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of an intrinsic when lowered.  <a href="#aa9d36b0d23c5c6f49b6d103ebd1d9d2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#aa51ff777a9b890f7933c344a7aebef4e">getUserCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *U) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of a given IR user when lowered.  <a href="#aa51ff777a9b890f7933c344a7aebef4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ac72c824d9cf06841d14e2eacb673b8e3">hasBranchDivergence</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if branch divergence exists.  <a href="#ac72c824d9cf06841d14e2eacb673b8e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a0c11bd87956b475b634021bfcee6bce1">isSourceOfDivergence</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *V) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether V is a source of divergence.  <a href="#a0c11bd87956b475b634021bfcee6bce1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ad9b97e9027fa07134ffb5217b4ce2c77">isLoweredToCall</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether calls to a function lower to actual program function calls.  <a href="#ad9b97e9027fa07134ffb5217b4ce2c77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a8d16f24684738519eefc3bb0ecf7ea65">getUnrollingPreferences</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html">UnrollingPreferences</a> &amp;UP) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target-customized preferences for the generic loop unrolling transformation.  <a href="#a8d16f24684738519eefc3bb0ecf7ea65"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Scalar Target Information</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#aa4c17e89b1ef061ed69f42b7cee93dbe">PopcntSupportKind</a> { <a class="el" href="classllvm_1_1TargetTransformInfo.html#aa4c17e89b1ef061ed69f42b7cee93dbea0ce99a3a4fe2b7f2771a7b288a99ed2c">PSK_Software</a>, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#aa4c17e89b1ef061ed69f42b7cee93dbea01deb9d0bc6399399b0d8377bd09201d">PSK_SlowHardware</a>, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#aa4c17e89b1ef061ed69f42b7cee93dbeac71465fd61f1ba8aa2c7c397722b5e05">PSK_FastHardware</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags indicating the kind of support for population count.  <a href="classllvm_1_1TargetTransformInfo.html#aa4c17e89b1ef061ed69f42b7cee93dbe">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a27c39fe900d03167d7e519f8d6cb94e2">isLegalAddImmediate</a> (int64_t Imm) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified immediate is legal add immediate, that is the target has add instructions which can add a register with the immediate without having to materialize the immediate into a register.  <a href="#a27c39fe900d03167d7e519f8d6cb94e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a33e1d30087a69bde585406645b12b4f7">isLegalICmpImmediate</a> (int64_t Imm) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified immediate is legal icmp immediate, that is the target has icmp instructions which can compare a register against the immediate without having to materialize the immediate into a register.  <a href="#a33e1d30087a69bde585406645b12b4f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#af1742f5fc2470f4fd8348108f310cd46">isLegalAddressingMode</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *BaseGV, int64_t BaseOffset, <a class="el" href="classbool.html">bool</a> HasBaseReg, int64_t Scale, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace=0) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the addressing mode represented by AM is legal for this target, for a load/store of the specified type.  <a href="#af1742f5fc2470f4fd8348108f310cd46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a97b0835e71d13c9322a3d4c2bbbff965">isLegalMaskedStore</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classDataType.html">DataType</a>, <a class="el" href="classint.html">int</a> Consecutive) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target works with masked instruction AVX2 allows masks for consecutive load and store for i32 and i64 elements.  <a href="#a97b0835e71d13c9322a3d4c2bbbff965"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a5d5b091df8e609b93e798cf5ebc2cdec">isLegalMaskedLoad</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classDataType.html">DataType</a>, <a class="el" href="classint.html">int</a> Consecutive) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a858d58dab739e4e46f54bfaf7dded64c">getScalingFactorCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *BaseGV, int64_t BaseOffset, <a class="el" href="classbool.html">bool</a> HasBaseReg, int64_t Scale, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace=0) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cost of the scaling factor used in the addressing mode represented by AM for this target, for a load/store of the specified type.  <a href="#a858d58dab739e4e46f54bfaf7dded64c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a547c815fb7093e41196bc8dd0c4b9317">isTruncateFree</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty1, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty2) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it's free to truncate a value of type Ty1 to type Ty2.  <a href="#a547c815fb7093e41196bc8dd0c4b9317"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#aaf0b3d5b94c9d742a2bdb9d221410682">isProfitableToHoist</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is profitable to hoist instruction in the then/else to before if.  <a href="#aaf0b3d5b94c9d742a2bdb9d221410682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a83f052a0d908e956128c8951451bde39">isTypeLegal</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this type is legal.  <a href="#a83f052a0d908e956128c8951451bde39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a887eb2dc691e04822c339221d2c0b6f4">getJumpBufAlignment</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target's jmp_buf alignment in bytes.  <a href="#a887eb2dc691e04822c339221d2c0b6f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#abc888f60885cb5125c103d15452873b4">getJumpBufSize</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target's jmp_buf size in bytes.  <a href="#abc888f60885cb5125c103d15452873b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a74d97d9e66d1007252d8609b7b8ccf21">shouldBuildLookupTables</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if switches should be turned into lookup tables for the target.  <a href="#a74d97d9e66d1007252d8609b7b8ccf21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#aefcecb11ac2d8e8c66ead3cf95bacb4c">enableAggressiveInterleaving</a> (<a class="el" href="classbool.html">bool</a> LoopHasReductions) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't restrict interleaved unrolling to small loops.  <a href="#aefcecb11ac2d8e8c66ead3cf95bacb4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1TargetTransformInfo.html#aa4c17e89b1ef061ed69f42b7cee93dbe">PopcntSupportKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a0998b713b1cd3661789b3f4391e46244">getPopcntSupport</a> (<a class="el" href="classunsigned.html">unsigned</a> IntTyWidthInBit) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return hardware support for population count.  <a href="#a0998b713b1cd3661789b3f4391e46244"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a01138d480dc0f9e11216e65d676a5bb9">haveFastSqrt</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the hardware has a fast square-root instruction.  <a href="#a01138d480dc0f9e11216e65d676a5bb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a7d7d01c4d33d8b02deca0071aafa97c9">getFPOpCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost of supporting the floating point operation of the specified type.  <a href="#a7d7d01c4d33d8b02deca0071aafa97c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ac13f91a87ce8723333fb5e14e56105ec">getIntImmCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost of materializing for the given integer immediate of the specified type.  <a href="#ac13f91a87ce8723333fb5e14e56105ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ae3f7ded11449f34b6902b635d6acfb90">getIntImmCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opc, <a class="el" href="classunsigned.html">unsigned</a> Idx, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost of materialization for the given integer immediate of the specified type for a given instruction.  <a href="#ae3f7ded11449f34b6902b635d6acfb90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a6f2bc0611d52e5a3e2dee3bdb72674fb">getIntImmCost</a> (<a class="el" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90">Intrinsic::ID</a> IID, <a class="el" href="classunsigned.html">unsigned</a> Idx, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Vector Target Information</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53ec">ShuffleKind</a> { <br/>
&#160;&#160;<a class="el" href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53ecab1ac8982cdb119f39a5fe74610a46796">SK_Broadcast</a>, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53ecaea788d98147161f25d5adc3ec6ce7e1f">SK_Reverse</a>, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53eca896c583a358fd81134abae5d94e29e2a">SK_Alternate</a>, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53eca466a4d581cf3a553414b9c2e889b944a">SK_InsertSubvector</a>, 
<br/>
&#160;&#160;<a class="el" href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53ecafd6c03f570400fcb24d861aa21ddffe9">SK_ExtractSubvector</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The various kinds of shuffle patterns for vector queries.  <a href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53ec">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a> { <a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a>, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4ca7aa61d9e9d33bdf28478754c69c59640">OK_UniformValue</a>, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4ca76d8855d96b8e66b9411ed74737ca8f7">OK_UniformConstantValue</a>, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4cacf63326297610dfbedd0ad408b54e3e4">OK_NonUniformConstantValue</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional information about an operand's possible values.  <a href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a> { <a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a> =  0, 
<a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5a974f46ced0fd416db695ce5da6059dcc">OP_PowerOf2</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional properties of an operand's values.  <a href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a729fc043d8ac87b3e81a3dc78a0611f4">getNumberOfRegisters</a> (<a class="el" href="classbool.html">bool</a> Vector) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ab3a881d37677c3b7211e368202f6f7f7">getRegisterBitWidth</a> (<a class="el" href="classbool.html">bool</a> Vector) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a1f509b0aecb17f98d7c9039d9c441baf">getMaxInterleaveFactor</a> (<a class="el" href="classunsigned.html">unsigned</a> VF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a6a9d8e494eada016e0a945a2013509b8">getArithmeticInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a> Opd1Info=<a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a>, <a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a> Opd2Info=<a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a>, <a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a> Opd1PropInfo=<a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a>, <a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a> Opd2PropInfo=<a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a677943099c69db4b5391de60b806b80c">getShuffleCost</a> (<a class="el" href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53ec">ShuffleKind</a> <a class="el" href="ARMAsmParser_8cpp.html#ad46e457485b0e36d5c628c68083f0a71">Kind</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Tp, <a class="el" href="classint.html">int</a> Index=0, <a class="el" href="classllvm_1_1Type.html">Type</a> *SubTp=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a453ec2b93d93a5b78a737c501266e104">getCastInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Dst, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a64573fde1c08c1d3572e5147039c7338">getCFInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a64163cc9b6c189b2829733dd4b6ef6d9">getCmpSelInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *ValTy, <a class="el" href="classllvm_1_1Type.html">Type</a> *CondTy=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a5f7e7e1b99d11c3b1b437a5b3cba41c0">getVectorInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Val, <a class="el" href="classunsigned.html">unsigned</a> Index=-1) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a1b178b55f0bfc23a27aa5ace23332204">getMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src, <a class="el" href="classunsigned.html">unsigned</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a5a2b19d828a5ce2f27092a1b374697c1">getMaskedMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src, <a class="el" href="classunsigned.html">unsigned</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#ad2fd03bd51645ad12714995e988b093e">getInterleavedMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *VecTy, <a class="el" href="classunsigned.html">unsigned</a> Factor, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; Indices, <a class="el" href="classunsigned.html">unsigned</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a58c65bee90b0fead29b2293c4ed69f88">getReductionCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classbool.html">bool</a> IsPairwiseForm) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of performing a vector reduction.  <a href="#a58c65bee90b0fead29b2293c4ed69f88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#aeb349dfe9de242e05ded1b541783b5df">getIntrinsicInstrCost</a> (<a class="el" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90">Intrinsic::ID</a> ID, <a class="el" href="classllvm_1_1Type.html">Type</a> *RetTy, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; Tys) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a87f547060ce6c3cc6ca1e031b2f667ac">getCallInstrCost</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *RetTy, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; Tys) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#accaae8bf378540f31e9b5b7614a0832b">getNumberOfParts</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Tp) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#aad1feb3c39700950c1b35d4da87515c4">getAddressComputationCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classbool.html">bool</a> IsComplex=<a class="el" href="SimplifyInstructions_8cpp.html#a6dd713bd88673625bb181528a61bdc85">false</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a15dce12440b34d5f7e08739d5be1cf61">getCostOfKeepingLiveOverCall</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; Tys) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a1503e425a52e05e0d016dd82c9976c4c">getTgtMemIntrinsic</a> (<a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *Inst, <a class="el" href="structllvm_1_1MemIntrinsicInfo.html">MemIntrinsicInfo</a> &amp;Info) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a1316097cdd2ad578474a531f31e06855">getOrCreateResultFromMemIntrinsic</a> (<a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *Inst, <a class="el" href="classllvm_1_1Type.html">Type</a> *ExpectedType) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This pass provides access to the codegen interfaces that are needed for IR-level transformations. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00058">58</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="afa38851d75434d1476444ac93f94cb4c"></a><!-- doxytag: member="llvm::TargetTransformInfo::OperandValueKind" ref="afa38851d75434d1476444ac93f94cb4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4c">llvm::TargetTransformInfo::OperandValueKind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Additional information about an operand's possible values. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac"></a><!-- doxytag: member="OK_AnyValue" ref="afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac" args="" -->OK_AnyValue</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afa38851d75434d1476444ac93f94cb4ca7aa61d9e9d33bdf28478754c69c59640"></a><!-- doxytag: member="OK_UniformValue" ref="afa38851d75434d1476444ac93f94cb4ca7aa61d9e9d33bdf28478754c69c59640" args="" -->OK_UniformValue</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afa38851d75434d1476444ac93f94cb4ca76d8855d96b8e66b9411ed74737ca8f7"></a><!-- doxytag: member="OK_UniformConstantValue" ref="afa38851d75434d1476444ac93f94cb4ca76d8855d96b8e66b9411ed74737ca8f7" args="" -->OK_UniformConstantValue</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afa38851d75434d1476444ac93f94cb4cacf63326297610dfbedd0ad408b54e3e4"></a><!-- doxytag: member="OK_NonUniformConstantValue" ref="afa38851d75434d1476444ac93f94cb4cacf63326297610dfbedd0ad408b54e3e4" args="" -->OK_NonUniformConstantValue</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00389">389</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a class="anchor" id="a733fb237f3037c95ed59de6055b176c5"></a><!-- doxytag: member="llvm::TargetTransformInfo::OperandValueProperties" ref="a733fb237f3037c95ed59de6055b176c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5">llvm::TargetTransformInfo::OperandValueProperties</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Additional properties of an operand's values. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072"></a><!-- doxytag: member="OP_None" ref="a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072" args="" -->OP_None</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a733fb237f3037c95ed59de6055b176c5a974f46ced0fd416db695ce5da6059dcc"></a><!-- doxytag: member="OP_PowerOf2" ref="a733fb237f3037c95ed59de6055b176c5a974f46ced0fd416db695ce5da6059dcc" args="" -->OP_PowerOf2</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00397">397</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa4c17e89b1ef061ed69f42b7cee93dbe"></a><!-- doxytag: member="llvm::TargetTransformInfo::PopcntSupportKind" ref="aa4c17e89b1ef061ed69f42b7cee93dbe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classllvm_1_1TargetTransformInfo.html#aa4c17e89b1ef061ed69f42b7cee93dbe">llvm::TargetTransformInfo::PopcntSupportKind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flags indicating the kind of support for population count. </p>
<p>Compared to the SW implementation, HW support is supposed to significantly boost the performance when the population is dense, and it may or may not degrade performance if the population is sparse. A HW support is considered as "Fast" if it can outperform, or is on a par with, SW implementation when the population is sparse; otherwise, it is considered as "Slow". </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa4c17e89b1ef061ed69f42b7cee93dbea0ce99a3a4fe2b7f2771a7b288a99ed2c"></a><!-- doxytag: member="PSK_Software" ref="aa4c17e89b1ef061ed69f42b7cee93dbea0ce99a3a4fe2b7f2771a7b288a99ed2c" args="" -->PSK_Software</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4c17e89b1ef061ed69f42b7cee93dbea01deb9d0bc6399399b0d8377bd09201d"></a><!-- doxytag: member="PSK_SlowHardware" ref="aa4c17e89b1ef061ed69f42b7cee93dbea01deb9d0bc6399399b0d8377bd09201d" args="" -->PSK_SlowHardware</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4c17e89b1ef061ed69f42b7cee93dbeac71465fd61f1ba8aa2c7c397722b5e05"></a><!-- doxytag: member="PSK_FastHardware" ref="aa4c17e89b1ef061ed69f42b7cee93dbeac71465fd61f1ba8aa2c7c397722b5e05" args="" -->PSK_FastHardware</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00289">289</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a class="anchor" id="af46433d0e36d3f80afc3a8c67b5c53ec"></a><!-- doxytag: member="llvm::TargetTransformInfo::ShuffleKind" ref="af46433d0e36d3f80afc3a8c67b5c53ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53ec">llvm::TargetTransformInfo::ShuffleKind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The various kinds of shuffle patterns for vector queries. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af46433d0e36d3f80afc3a8c67b5c53ecab1ac8982cdb119f39a5fe74610a46796"></a><!-- doxytag: member="SK_Broadcast" ref="af46433d0e36d3f80afc3a8c67b5c53ecab1ac8982cdb119f39a5fe74610a46796" args="" -->SK_Broadcast</em>&nbsp;</td><td>
<p>Broadcast element 0 to all other elements. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af46433d0e36d3f80afc3a8c67b5c53ecaea788d98147161f25d5adc3ec6ce7e1f"></a><!-- doxytag: member="SK_Reverse" ref="af46433d0e36d3f80afc3a8c67b5c53ecaea788d98147161f25d5adc3ec6ce7e1f" args="" -->SK_Reverse</em>&nbsp;</td><td>
<p>Reverse the order of the vector. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af46433d0e36d3f80afc3a8c67b5c53eca896c583a358fd81134abae5d94e29e2a"></a><!-- doxytag: member="SK_Alternate" ref="af46433d0e36d3f80afc3a8c67b5c53eca896c583a358fd81134abae5d94e29e2a" args="" -->SK_Alternate</em>&nbsp;</td><td>
<p>Choose alternate elements from vector. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af46433d0e36d3f80afc3a8c67b5c53eca466a4d581cf3a553414b9c2e889b944a"></a><!-- doxytag: member="SK_InsertSubvector" ref="af46433d0e36d3f80afc3a8c67b5c53eca466a4d581cf3a553414b9c2e889b944a" args="" -->SK_InsertSubvector</em>&nbsp;</td><td>
<p>InsertSubvector. Index indicates start offset. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af46433d0e36d3f80afc3a8c67b5c53ecafd6c03f570400fcb24d861aa21ddffe9"></a><!-- doxytag: member="SK_ExtractSubvector" ref="af46433d0e36d3f80afc3a8c67b5c53ecafd6c03f570400fcb24d861aa21ddffe9" args="" -->SK_ExtractSubvector</em>&nbsp;</td><td>
<p>ExtractSubvector Index indicates start offset. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00380">380</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac44f6b9fdbb5f9cc199f8329cb0b272c"></a><!-- doxytag: member="llvm::TargetTransformInfo::TargetCostConstants" ref="ac44f6b9fdbb5f9cc199f8329cb0b272c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classllvm_1_1TargetTransformInfo.html#ac44f6b9fdbb5f9cc199f8329cb0b272c">llvm::TargetTransformInfo::TargetCostConstants</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Underlying constants for 'cost' values in this interface. </p>
<p>Many APIs in this interface return a cost. This enum defines the fundamental values that should be used to interpret (and produce) those costs. The costs are returned as an unsigned rather than a member of this enumeration because it is expected that the cost of one IR instruction may have a multiplicative factor to it or otherwise won't fit directly into the enum. Moreover, it is common to sum or average costs which works better as simple integral values. Thus this enum only provides constants.</p>
<p>Note that these costs should usually reflect the intersection of code-size cost and execution cost. A free instruction is typically one that folds into another instruction. For example, reg-to-reg moves can often be skipped by renaming the registers in the CPU, but they still are encoded and thus wouldn't be considered 'free' here. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac44f6b9fdbb5f9cc199f8329cb0b272ca89f768b1267e3083b4eb05b4ab77e717"></a><!-- doxytag: member="TCC_Free" ref="ac44f6b9fdbb5f9cc199f8329cb0b272ca89f768b1267e3083b4eb05b4ab77e717" args="" -->TCC_Free</em>&nbsp;</td><td>
<p>Expected to fold away in lowering. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac44f6b9fdbb5f9cc199f8329cb0b272cae46c9eecc49bd2dc253c607e78a0fb86"></a><!-- doxytag: member="TCC_Basic" ref="ac44f6b9fdbb5f9cc199f8329cb0b272cae46c9eecc49bd2dc253c607e78a0fb86" args="" -->TCC_Basic</em>&nbsp;</td><td>
<p>The cost of a typical 'add' instruction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac44f6b9fdbb5f9cc199f8329cb0b272ca022565d444ccf496c0414bccefbcd9c8"></a><!-- doxytag: member="TCC_Expensive" ref="ac44f6b9fdbb5f9cc199f8329cb0b272ca022565d444ccf496c0414bccefbcd9c8" args="" -->TCC_Expensive</em>&nbsp;</td><td>
<p>The cost of a 'div' instruction on x86. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00111">111</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af1bf12b2f33b7e30f8f361a1e7642079"></a><!-- doxytag: member="llvm::TargetTransformInfo::TargetTransformInfo" ref="af1bf12b2f33b7e30f8f361a1e7642079" args="(T Impl)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TargetTransformInfo.html#af1bf12b2f33b7e30f8f361a1e7642079">llvm::TargetTransformInfo::TargetTransformInfo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classT.html">T</a>&#160;</td>
          <td class="paramname"><em>Impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a TTI object using a type implementing the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below. </p>
<p>This is used by targets to construct a TTI wrapping their target-specific implementaion that encodes appropriate costs for their target. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00810">810</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a class="anchor" id="a68bb8cdc73630ccd03ca7998503865d1"></a><!-- doxytag: member="llvm::TargetTransformInfo::TargetTransformInfo" ref="a68bb8cdc73630ccd03ca7998503865d1" args="(const DataLayout *DL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TargetTransformInfo.html#af1bf12b2f33b7e30f8f361a1e7642079">TargetTransformInfo::TargetTransformInfo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> *&#160;</td>
          <td class="paramname"><em>DL</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a baseline TTI object using a minimal implementation of the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below. </p>
<p>The TTI implementation will reflect the information in the <a class="el" href="classllvm_1_1DataLayout.html" title="A parsed version of the target data layout string in and methods for querying it.">DataLayout</a> provided if non-null. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00036">36</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab158463a734f57c86e685364527ebaa4"></a><!-- doxytag: member="llvm::TargetTransformInfo::TargetTransformInfo" ref="ab158463a734f57c86e685364527ebaa4" args="(TargetTransformInfo &amp;&amp;Arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TargetTransformInfo.html#af1bf12b2f33b7e30f8f361a1e7642079">TargetTransformInfo::TargetTransformInfo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00041">41</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9e9d106cef4491370c43c4f136fc050"></a><!-- doxytag: member="llvm::TargetTransformInfo::~TargetTransformInfo" ref="af9e9d106cef4491370c43c4f136fc050" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TargetTransformInfo.html#af9e9d106cef4491370c43c4f136fc050">TargetTransformInfo::~TargetTransformInfo</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00039">39</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aefcecb11ac2d8e8c66ead3cf95bacb4c"></a><!-- doxytag: member="llvm::TargetTransformInfo::enableAggressiveInterleaving" ref="aefcecb11ac2d8e8c66ead3cf95bacb4c" args="(bool LoopHasReductions) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#aefcecb11ac2d8e8c66ead3cf95bacb4c">TargetTransformInfo::enableAggressiveInterleaving</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>LoopHasReductions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Don't restrict interleaved unrolling to small loops. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00152">152</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad1feb3c39700950c1b35d4da87515c4"></a><!-- doxytag: member="llvm::TargetTransformInfo::getAddressComputationCost" ref="aad1feb3c39700950c1b35d4da87515c4" args="(Type *Ty, bool IsComplex=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#aad1feb3c39700950c1b35d4da87515c4">TargetTransformInfo::getAddressComputationCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsComplex</em> = <code><a class="el" href="SimplifyInstructions_8cpp.html#a6dd713bd88673625bb181528a61bdc85">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The cost of the address computation. For most targets this can be merged into the instruction indexing mode. Some targets might want to distinguish between address computation for memory operations on vector types and scalar types. Such targets should override this function. The 'IsComplex' parameter is a hint that the address computation is likely to involve multiple instructions and as such unlikely to be merged into the address indexing mode. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00262">262</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="RewriteStatepointsForGC_8cpp_source.html#l01861">chainToBasePointerCost()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a9d8e494eada016e0a945a2013509b8"></a><!-- doxytag: member="llvm::TargetTransformInfo::getArithmeticInstrCost" ref="a6a9d8e494eada016e0a945a2013509b8" args="(unsigned Opcode, Type *Ty, OperandValueKind Opd1Info=OK_AnyValue, OperandValueKind Opd2Info=OK_AnyValue, OperandValueProperties Opd1PropInfo=OP_None, OperandValueProperties Opd2PropInfo=OP_None) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a6a9d8e494eada016e0a945a2013509b8">TargetTransformInfo::getArithmeticInstrCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a>&#160;</td>
          <td class="paramname"><em>Opd1Info</em> = <code><a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a>&#160;</td>
          <td class="paramname"><em>Opd2Info</em> = <code><a class="el" href="classllvm_1_1TargetTransformInfo.html#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a>&#160;</td>
          <td class="paramname"><em>Opd1PropInfo</em> = <code><a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a>&#160;</td>
          <td class="paramname"><em>Opd2PropInfo</em> = <code><a class="el" href="classllvm_1_1TargetTransformInfo.html#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The expected cost of arithmetic ops, such as mul, xor, fsub, etc. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00195">195</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="IndVarSimplify_8cpp_source.html#l00766">visitIVCast()</a>.</p>

</div>
</div>
<a class="anchor" id="ac57143b0af7b0b64eac63f2898c3b83e"></a><!-- doxytag: member="llvm::TargetTransformInfo::getCallCost" ref="ac57143b0af7b0b64eac63f2898c3b83e" args="(FunctionType *FTy, int NumArgs=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ac57143b0af7b0b64eac63f2898c3b83e">TargetTransformInfo::getCallCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1FunctionType.html">FunctionType</a> *&#160;</td>
          <td class="paramname"><em>FTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>NumArgs</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate the cost of a function call when lowered. </p>
<p>The contract for this is the same as <code>getOperationCost</code> except that it supports an interface that provides extra information specific to call instructions.</p>
<p>This is the most basic query for estimating call cost: it only knows the function type and (potentially) the number of arguments at the call site. The latter is only interesting for varargs function types. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00054">54</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38259cfb42552b62e29800357fb19615"></a><!-- doxytag: member="llvm::TargetTransformInfo::getCallCost" ref="a38259cfb42552b62e29800357fb19615" args="(const Function *F, int NumArgs=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ac57143b0af7b0b64eac63f2898c3b83e">llvm::TargetTransformInfo::getCallCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>NumArgs</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate the cost of calling a specific function when lowered. </p>
<p>This overload adds the ability to reason about the particular function being called in the event it is a library call with special lowering. </p>

</div>
</div>
<a class="anchor" id="ab8520bbb6695a8f502dc7d800efe44c3"></a><!-- doxytag: member="llvm::TargetTransformInfo::getCallCost" ref="ab8520bbb6695a8f502dc7d800efe44c3" args="(const Function *F, ArrayRef&lt; const Value * &gt; Arguments) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ac57143b0af7b0b64eac63f2898c3b83e">TargetTransformInfo::getCallCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;&#160;</td>
          <td class="paramname"><em>Arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate the cost of calling a specific function when lowered. </p>
<p>This overload allows specifying a set of candidate argument values. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00060">60</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87f547060ce6c3cc6ca1e031b2f667ac"></a><!-- doxytag: member="llvm::TargetTransformInfo::getCallInstrCost" ref="a87f547060ce6c3cc6ca1e031b2f667ac" args="(Function *F, Type *RetTy, ArrayRef&lt; Type * &gt; Tys) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a87f547060ce6c3cc6ca1e031b2f667ac">TargetTransformInfo::getCallInstrCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>RetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;&#160;</td>
          <td class="paramname"><em>Tys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The cost of Call instructions. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00253">253</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l02984">getVectorCallCost()</a>.</p>

</div>
</div>
<a class="anchor" id="a453ec2b93d93a5b78a737c501266e104"></a><!-- doxytag: member="llvm::TargetTransformInfo::getCastInstrCost" ref="a453ec2b93d93a5b78a737c501266e104" args="(unsigned Opcode, Type *Dst, Type *Src) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a453ec2b93d93a5b78a737c501266e104">TargetTransformInfo::getCastInstrCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The expected cost of cast instructions, such as bitcast, trunc, zext, etc. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00208">208</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="RewriteStatepointsForGC_8cpp_source.html#l01861">chainToBasePointerCost()</a>.</p>

</div>
</div>
<a class="anchor" id="a64573fde1c08c1d3572e5147039c7338"></a><!-- doxytag: member="llvm::TargetTransformInfo::getCFInstrCost" ref="a64573fde1c08c1d3572e5147039c7338" args="(unsigned Opcode) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a64573fde1c08c1d3572e5147039c7338">TargetTransformInfo::getCFInstrCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The expected cost of control-flow related instructions such as Phi, Ret, Br. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00213">213</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64163cc9b6c189b2829733dd4b6ef6d9"></a><!-- doxytag: member="llvm::TargetTransformInfo::getCmpSelInstrCost" ref="a64163cc9b6c189b2829733dd4b6ef6d9" args="(unsigned Opcode, Type *ValTy, Type *CondTy=nullptr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a64163cc9b6c189b2829733dd4b6ef6d9">TargetTransformInfo::getCmpSelInstrCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>ValTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>CondTy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The expected cost of compare and select instructions. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00217">217</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15dce12440b34d5f7e08739d5be1cf61"></a><!-- doxytag: member="llvm::TargetTransformInfo::getCostOfKeepingLiveOverCall" ref="a15dce12440b34d5f7e08739d5be1cf61" args="(ArrayRef&lt; Type * &gt; Tys) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a15dce12440b34d5f7e08739d5be1cf61">TargetTransformInfo::getCostOfKeepingLiveOverCall</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;&#160;</td>
          <td class="paramname"><em>Tys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The cost, if any, of keeping values of the given types alive over a callsite.</dd></dl>
<p>Some types may require the use of register classes that do not have any callee-saved registers, so would require a spill and fill. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00273">273</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d7d01c4d33d8b02deca0071aafa97c9"></a><!-- doxytag: member="llvm::TargetTransformInfo::getFPOpCost" ref="a7d7d01c4d33d8b02deca0071aafa97c9" args="(Type *Ty) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a7d7d01c4d33d8b02deca0071aafa97c9">TargetTransformInfo::getFPOpCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the expected cost of supporting the floating point operation of the specified type. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00165">165</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abceb0d7d889b22a0ba068f809bd0479b"></a><!-- doxytag: member="llvm::TargetTransformInfo::getGEPCost" ref="abceb0d7d889b22a0ba068f809bd0479b" args="(const Value *Ptr, ArrayRef&lt; const Value * &gt; Operands) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#abceb0d7d889b22a0ba068f809bd0479b">llvm::TargetTransformInfo::getGEPCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;&#160;</td>
          <td class="paramname"><em>Operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate the cost of a GEP operation when lowered. </p>
<p>The contract for this function is the same as <code>getOperationCost</code> except that it supports an interface that provides extra information specific to the GEP operation. </p>

</div>
</div>
<a class="anchor" id="ad2fd03bd51645ad12714995e988b093e"></a><!-- doxytag: member="llvm::TargetTransformInfo::getInterleavedMemoryOpCost" ref="ad2fd03bd51645ad12714995e988b093e" args="(unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef&lt; unsigned &gt; Indices, unsigned Alignment, unsigned AddressSpace) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ad2fd03bd51645ad12714995e988b093e">TargetTransformInfo::getInterleavedMemoryOpCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>VecTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>AddressSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The cost of the interleaved memory operation. <code>Opcode</code> is the memory operation code <code>VecTy</code> is the vector type of the interleaved access. <code>Factor</code> is the interleave factor <code>Indices</code> is the indices for interleaved load members (as interleaved load allows gaps) <code>Alignment</code> is the alignment of the memory operation <code>AddressSpace</code> is address space of the pointer. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00240">240</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac13f91a87ce8723333fb5e14e56105ec"></a><!-- doxytag: member="llvm::TargetTransformInfo::getIntImmCost" ref="ac13f91a87ce8723333fb5e14e56105ec" args="(const APInt &amp;Imm, Type *Ty) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ac13f91a87ce8723333fb5e14e56105ec">TargetTransformInfo::getIntImmCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;&#160;</td>
          <td class="paramname"><em>Imm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the expected cost of materializing for the given integer immediate of the specified type. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00169">169</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f7ded11449f34b6902b635d6acfb90"></a><!-- doxytag: member="llvm::TargetTransformInfo::getIntImmCost" ref="ae3f7ded11449f34b6902b635d6acfb90" args="(unsigned Opc, unsigned Idx, const APInt &amp;Imm, Type *Ty) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ac13f91a87ce8723333fb5e14e56105ec">TargetTransformInfo::getIntImmCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;&#160;</td>
          <td class="paramname"><em>Imm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the expected cost of materialization for the given integer immediate of the specified type for a given instruction. </p>
<p>The cost can be zero if the immediate can be folded into the specified instruction. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00173">173</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f2bc0611d52e5a3e2dee3bdb72674fb"></a><!-- doxytag: member="llvm::TargetTransformInfo::getIntImmCost" ref="a6f2bc0611d52e5a3e2dee3bdb72674fb" args="(Intrinsic::ID IID, unsigned Idx, const APInt &amp;Imm, Type *Ty) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ac13f91a87ce8723333fb5e14e56105ec">TargetTransformInfo::getIntImmCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90">Intrinsic::ID</a>&#160;</td>
          <td class="paramname"><em>IID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;&#160;</td>
          <td class="paramname"><em>Imm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00178">178</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada3b0313ffc99f47c742434ef58e9028"></a><!-- doxytag: member="llvm::TargetTransformInfo::getIntrinsicCost" ref="ada3b0313ffc99f47c742434ef58e9028" args="(Intrinsic::ID IID, Type *RetTy, ArrayRef&lt; Type * &gt; ParamTys) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ada3b0313ffc99f47c742434ef58e9028">llvm::TargetTransformInfo::getIntrinsicCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90">Intrinsic::ID</a>&#160;</td>
          <td class="paramname"><em>IID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>RetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;&#160;</td>
          <td class="paramname"><em>ParamTys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate the cost of an intrinsic when lowered. </p>
<p>Mirrors the <code>getCallCost</code> method but uses an intrinsic identifier. </p>

</div>
</div>
<a class="anchor" id="aa9d36b0d23c5c6f49b6d103ebd1d9d2b"></a><!-- doxytag: member="llvm::TargetTransformInfo::getIntrinsicCost" ref="aa9d36b0d23c5c6f49b6d103ebd1d9d2b" args="(Intrinsic::ID IID, Type *RetTy, ArrayRef&lt; const Value * &gt; Arguments) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ada3b0313ffc99f47c742434ef58e9028">TargetTransformInfo::getIntrinsicCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90">Intrinsic::ID</a>&#160;</td>
          <td class="paramname"><em>IID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>RetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;&#160;</td>
          <td class="paramname"><em>Arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate the cost of an intrinsic when lowered. </p>
<p>Mirrors the <code>getCallCost</code> method but uses an intrinsic identifier. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00066">66</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb349dfe9de242e05ded1b541783b5df"></a><!-- doxytag: member="llvm::TargetTransformInfo::getIntrinsicInstrCost" ref="aeb349dfe9de242e05ded1b541783b5df" args="(Intrinsic::ID ID, Type *RetTy, ArrayRef&lt; Type * &gt; Tys) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#aeb349dfe9de242e05ded1b541783b5df">TargetTransformInfo::getIntrinsicInstrCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90">Intrinsic::ID</a>&#160;</td>
          <td class="paramname"><em>ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>RetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;&#160;</td>
          <td class="paramname"><em>Tys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The cost of <a class="el" href="namespacellvm_1_1Intrinsic.html" title="This namespace contains an enum with a value for every intrinsic/builtin function known by LLVM...">Intrinsic</a> instructions. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00248">248</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l03035">getVectorIntrinsicCost()</a>.</p>

</div>
</div>
<a class="anchor" id="a887eb2dc691e04822c339221d2c0b6f4"></a><!-- doxytag: member="llvm::TargetTransformInfo::getJumpBufAlignment" ref="a887eb2dc691e04822c339221d2c0b6f4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a887eb2dc691e04822c339221d2c0b6f4">TargetTransformInfo::getJumpBufAlignment</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the target's jmp_buf alignment in bytes. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00140">140</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc888f60885cb5125c103d15452873b4"></a><!-- doxytag: member="llvm::TargetTransformInfo::getJumpBufSize" ref="abc888f60885cb5125c103d15452873b4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#abc888f60885cb5125c103d15452873b4">TargetTransformInfo::getJumpBufSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the target's jmp_buf size in bytes. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00144">144</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a2b19d828a5ce2f27092a1b374697c1"></a><!-- doxytag: member="llvm::TargetTransformInfo::getMaskedMemoryOpCost" ref="a5a2b19d828a5ce2f27092a1b374697c1" args="(unsigned Opcode, Type *Src, unsigned Alignment, unsigned AddressSpace) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a5a2b19d828a5ce2f27092a1b374697c1">TargetTransformInfo::getMaskedMemoryOpCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>AddressSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The cost of masked Load and Store instructions. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00234">234</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f509b0aecb17f98d7c9039d9c441baf"></a><!-- doxytag: member="llvm::TargetTransformInfo::getMaxInterleaveFactor" ref="a1f509b0aecb17f98d7c9039d9c441baf" args="(unsigned VF) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a1f509b0aecb17f98d7c9039d9c441baf">TargetTransformInfo::getMaxInterleaveFactor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>VF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum interleave factor that any transform should try to perform for this target. This number depends on the level of parallelism and the number of execution units in the CPU. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00191">191</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b178b55f0bfc23a27aa5ace23332204"></a><!-- doxytag: member="llvm::TargetTransformInfo::getMemoryOpCost" ref="a1b178b55f0bfc23a27aa5ace23332204" args="(unsigned Opcode, Type *Src, unsigned Alignment, unsigned AddressSpace) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a1b178b55f0bfc23a27aa5ace23332204">TargetTransformInfo::getMemoryOpCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>AddressSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The cost of Load and Store instructions. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00227">227</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="accaae8bf378540f31e9b5b7614a0832b"></a><!-- doxytag: member="llvm::TargetTransformInfo::getNumberOfParts" ref="accaae8bf378540f31e9b5b7614a0832b" args="(Type *Tp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#accaae8bf378540f31e9b5b7614a0832b">TargetTransformInfo::getNumberOfParts</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Tp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of pieces into which the provided type must be split during legalization. Zero is returned when the answer is unknown. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00258">258</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a729fc043d8ac87b3e81a3dc78a0611f4"></a><!-- doxytag: member="llvm::TargetTransformInfo::getNumberOfRegisters" ref="a729fc043d8ac87b3e81a3dc78a0611f4" args="(bool Vector) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a729fc043d8ac87b3e81a3dc78a0611f4">TargetTransformInfo::getNumberOfRegisters</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of scalar or vector registers that the target has. If 'Vectors' is true, it returns the number of vector registers. If it is set to false, it returns the number of scalar registers. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00183">183</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65495ba8e884cf7cd52e6651b78d4517"></a><!-- doxytag: member="llvm::TargetTransformInfo::getOperationCost" ref="a65495ba8e884cf7cd52e6651b78d4517" args="(unsigned Opcode, Type *Ty, Type *OpTy=nullptr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a65495ba8e884cf7cd52e6651b78d4517">TargetTransformInfo::getOperationCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>OpTy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate the cost of a specific operation when lowered. </p>
<p>Note that this is designed to work on an arbitrary synthetic opcode, and thus work for hypothetical queries before an instruction has even been formed. However, this does *not* work for GEPs, and must not be called for a GEP instruction. Instead, use the dedicated getGEPCost interface as analyzing a GEP's cost required more information.</p>
<p>Typically only the result type is required, and the operand type can be omitted. However, if the opcode is one of the cast instructions, the operand type is required.</p>
<p>The returned cost is defined in terms of <code>TargetCostConstants</code>, see its comments for a detailed explanation of the cost values. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00049">49</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1316097cdd2ad578474a531f31e06855"></a><!-- doxytag: member="llvm::TargetTransformInfo::getOrCreateResultFromMemIntrinsic" ref="a1316097cdd2ad578474a531f31e06855" args="(IntrinsicInst *Inst, Type *ExpectedType) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Value.html">Value</a> * <a class="el" href="classllvm_1_1TargetTransformInfo.html#a1316097cdd2ad578474a531f31e06855">TargetTransformInfo::getOrCreateResultFromMemIntrinsic</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *&#160;</td>
          <td class="paramname"><em>Inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>ExpectedType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>A value which is the result of the given memory intrinsic. New instructions may be created to extract the result from the given intrinsic memory operation. Returns nullptr if the target cannot create a result from the given intrinsic. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00282">282</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0998b713b1cd3661789b3f4391e46244"></a><!-- doxytag: member="llvm::TargetTransformInfo::getPopcntSupport" ref="a0998b713b1cd3661789b3f4391e46244" args="(unsigned IntTyWidthInBit) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TargetTransformInfo.html#aa4c17e89b1ef061ed69f42b7cee93dbe">TargetTransformInfo::PopcntSupportKind</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a0998b713b1cd3661789b3f4391e46244">TargetTransformInfo::getPopcntSupport</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>IntTyWidthInBit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return hardware support for population count. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00157">157</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58c65bee90b0fead29b2293c4ed69f88"></a><!-- doxytag: member="llvm::TargetTransformInfo::getReductionCost" ref="a58c65bee90b0fead29b2293c4ed69f88" args="(unsigned Opcode, Type *Ty, bool IsPairwiseForm) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a58c65bee90b0fead29b2293c4ed69f88">TargetTransformInfo::getReductionCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsPairwiseForm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the cost of performing a vector reduction. </p>
<p>This is the cost of reducing the vector value of type <code>Ty</code> to a scalar value using the operation denoted by <code>Opcode</code>. The form of the reduction can either be a pairwise reduction or a reduction that splits the vector at every reduction level.</p>
<p>Pairwise: (v0, v1, v2, v3) ((v0+v1), (v2, v3), undef, undef) Split: (v0, v1, v2, v3) ((v0+v2), (v1+v3), undef, undef) </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00267">267</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3a881d37677c3b7211e368202f6f7f7"></a><!-- doxytag: member="llvm::TargetTransformInfo::getRegisterBitWidth" ref="ab3a881d37677c3b7211e368202f6f7f7" args="(bool Vector) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ab3a881d37677c3b7211e368202f6f7f7">TargetTransformInfo::getRegisterBitWidth</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The width of the largest scalar or vector register type. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00187">187</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a858d58dab739e4e46f54bfaf7dded64c"></a><!-- doxytag: member="llvm::TargetTransformInfo::getScalingFactorCost" ref="a858d58dab739e4e46f54bfaf7dded64c" args="(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset, bool HasBaseReg, int64_t Scale, unsigned AddrSpace=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a858d58dab739e4e46f54bfaf7dded64c">TargetTransformInfo::getScalingFactorCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *&#160;</td>
          <td class="paramname"><em>BaseGV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>BaseOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>HasBaseReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>Scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>AddrSpace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the cost of the scaling factor used in the addressing mode represented by AM for this target, for a load/store of the specified type. </p>
<p>If the AM is supported, the return value must be &gt;= 0. If the AM is not supported, it returns a negative value. TODO: Handle pre/postinc as well. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00119">119</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01479">getScalingFactorCost()</a>.</p>

</div>
</div>
<a class="anchor" id="a677943099c69db4b5391de60b806b80c"></a><!-- doxytag: member="llvm::TargetTransformInfo::getShuffleCost" ref="a677943099c69db4b5391de60b806b80c" args="(ShuffleKind Kind, Type *Tp, int Index=0, Type *SubTp=nullptr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a677943099c69db4b5391de60b806b80c">TargetTransformInfo::getShuffleCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html#af46433d0e36d3f80afc3a8c67b5c53ec">ShuffleKind</a>&#160;</td>
          <td class="paramname"><em>Kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>Index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>SubTp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The cost of a shuffle instruction of kind Kind and of type Tp. The index and subtype parameters are used by the subvector insertion and extraction shuffle kinds. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00203">203</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1503e425a52e05e0d016dd82c9976c4c"></a><!-- doxytag: member="llvm::TargetTransformInfo::getTgtMemIntrinsic" ref="a1503e425a52e05e0d016dd82c9976c4c" args="(IntrinsicInst *Inst, MemIntrinsicInfo &amp;Info) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a1503e425a52e05e0d016dd82c9976c4c">TargetTransformInfo::getTgtMemIntrinsic</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *&#160;</td>
          <td class="paramname"><em>Inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1MemIntrinsicInfo.html">MemIntrinsicInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>Info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the intrinsic is a supported memory intrinsic. Info will contain additional information - whether the intrinsic may write or read to memory, volatility and the pointer. Info is undefined if false is returned. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00277">277</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d16f24684738519eefc3bb0ecf7ea65"></a><!-- doxytag: member="llvm::TargetTransformInfo::getUnrollingPreferences" ref="a8d16f24684738519eefc3bb0ecf7ea65" args="(Loop *L, UnrollingPreferences &amp;UP) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classllvm_1_1TargetTransformInfo.html#a8d16f24684738519eefc3bb0ecf7ea65">TargetTransformInfo::getUnrollingPreferences</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html">UnrollingPreferences</a> &amp;&#160;</td>
          <td class="paramname"><em>UP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get target-customized preferences for the generic loop unrolling transformation. </p>
<p>The caller will initialize UP with the current target-independent defaults. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00087">87</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa51ff777a9b890f7933c344a7aebef4e"></a><!-- doxytag: member="llvm::TargetTransformInfo::getUserCost" ref="aa51ff777a9b890f7933c344a7aebef4e" args="(const User *U) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#aa51ff777a9b890f7933c344a7aebef4e">TargetTransformInfo::getUserCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimate the cost of a given IR user when lowered. </p>
<p>This can estimate the cost of either a <a class="el" href="classllvm_1_1ConstantExpr.html" title="ConstantExpr - a constant value that is initialized with an expression using other constant values...">ConstantExpr</a> or <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> when lowered. It has two primary advantages over the <code>getOperationCost</code> and <code>getGEPCost</code> above, and one significant disadvantage: it can only be used when the IR construct has already been formed.</p>
<p>The advantages are that it can inspect the SSA use graph to reason more accurately about the cost. For example, all-constant-GEPs can often be folded into a load or other instruction, but if they are used in some other context they may not be folded. This routine can distinguish such cases.</p>
<p>The returned cost is defined in terms of <code>TargetCostConstants</code>, see its comments for a detailed explanation of the cost values. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00071">71</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="CodeMetrics_8cpp_source.html#l00111">llvm::CodeMetrics::analyzeBasicBlock()</a>, <a class="el" href="LoopUnrollPass_8cpp_source.html#l00468">analyzeLoopUnrollCost()</a>, and <a class="el" href="SimplifyCFG_8cpp_source.html#l00226">ComputeSpeculationCost()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f7e7e1b99d11c3b1b437a5b3cba41c0"></a><!-- doxytag: member="llvm::TargetTransformInfo::getVectorInstrCost" ref="a5f7e7e1b99d11c3b1b437a5b3cba41c0" args="(unsigned Opcode, Type *Val, unsigned Index=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a5f7e7e1b99d11c3b1b437a5b3cba41c0">TargetTransformInfo::getVectorInstrCost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The expected cost of vector Insert and Extract. <a class="el" href="classllvm_1_1Use.html" title="A Use represents the edge between a Value definition and its users.">Use</a> -1 to indicate that there is no information on the index value. </dd></dl>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00222">222</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l02962">getScalarizationOverhead()</a>.</p>

</div>
</div>
<a class="anchor" id="ac72c824d9cf06841d14e2eacb673b8e3"></a><!-- doxytag: member="llvm::TargetTransformInfo::hasBranchDivergence" ref="ac72c824d9cf06841d14e2eacb673b8e3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ac72c824d9cf06841d14e2eacb673b8e3">TargetTransformInfo::hasBranchDivergence</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if branch divergence exists. </p>
<p>Branch divergence has a significantly negative impact on GPU performance when threads in the same wavefront take different paths due to conditional branches. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00075">75</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01138d480dc0f9e11216e65d676a5bb9"></a><!-- doxytag: member="llvm::TargetTransformInfo::haveFastSqrt" ref="a01138d480dc0f9e11216e65d676a5bb9" args="(Type *Ty) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a01138d480dc0f9e11216e65d676a5bb9">TargetTransformInfo::haveFastSqrt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the hardware has a fast square-root instruction. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00161">161</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ae49cc86eae7758dfb1d039b7e35614"></a><!-- doxytag: member="llvm::TargetTransformInfo::invalidate" ref="a4ae49cc86eae7758dfb1d039b7e35614" args="(Function &amp;, const PreservedAnalyses &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a4ae49cc86eae7758dfb1d039b7e35614">llvm::TargetTransformInfo::invalidate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1PreservedAnalyses.html">PreservedAnalyses</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle the invalidation of this information. </p>
<p>When used as a result of <code><a class="el" href="classllvm_1_1TargetIRAnalysis.html" title="Analysis pass providing the TargetTransformInfo.">TargetIRAnalysis</a></code> this method will be called when the function this was computed for changes. When it returns false, the information is preserved across those changes. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00087">87</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a class="anchor" id="a27c39fe900d03167d7e519f8d6cb94e2"></a><!-- doxytag: member="llvm::TargetTransformInfo::isLegalAddImmediate" ref="a27c39fe900d03167d7e519f8d6cb94e2" args="(int64_t Imm) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a27c39fe900d03167d7e519f8d6cb94e2">TargetTransformInfo::isLegalAddImmediate</a> </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>Imm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the specified immediate is legal add immediate, that is the target has add instructions which can add a register with the immediate without having to materialize the immediate into a register. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00092">92</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af1742f5fc2470f4fd8348108f310cd46"></a><!-- doxytag: member="llvm::TargetTransformInfo::isLegalAddressingMode" ref="af1742f5fc2470f4fd8348108f310cd46" args="(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset, bool HasBaseReg, int64_t Scale, unsigned AddrSpace=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#af1742f5fc2470f4fd8348108f310cd46">TargetTransformInfo::isLegalAddressingMode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *&#160;</td>
          <td class="paramname"><em>BaseGV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>BaseOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>HasBaseReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>Scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>AddrSpace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the addressing mode represented by AM is legal for this target, for a load/store of the specified type. </p>
<p>The type may be VoidTy, in which case only return true if the addressing mode is legal for a load/store of any legal type. TODO: Handle pre/postinc as well. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00100">100</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="StraightLineStrengthReduce_8cpp_source.html#l00275">isAddFoldable()</a>, <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01362">isAMCompletelyFolded()</a>, and <a class="el" href="NaryReassociate_8cpp_source.html#l00287">isGEPFoldable()</a>.</p>

</div>
</div>
<a class="anchor" id="a33e1d30087a69bde585406645b12b4f7"></a><!-- doxytag: member="llvm::TargetTransformInfo::isLegalICmpImmediate" ref="a33e1d30087a69bde585406645b12b4f7" args="(int64_t Imm) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a33e1d30087a69bde585406645b12b4f7">TargetTransformInfo::isLegalICmpImmediate</a> </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>Imm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the specified immediate is legal icmp immediate, that is the target has icmp instructions which can compare a register against the immediate without having to materialize the immediate into a register. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00096">96</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01362">isAMCompletelyFolded()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d5b091df8e609b93e798cf5ebc2cdec"></a><!-- doxytag: member="llvm::TargetTransformInfo::isLegalMaskedLoad" ref="a5d5b091df8e609b93e798cf5ebc2cdec" args="(Type *DataType, int Consecutive) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a5d5b091df8e609b93e798cf5ebc2cdec">TargetTransformInfo::isLegalMaskedLoad</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>DataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>Consecutive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00114">114</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97b0835e71d13c9322a3d4c2bbbff965"></a><!-- doxytag: member="llvm::TargetTransformInfo::isLegalMaskedStore" ref="a97b0835e71d13c9322a3d4c2bbbff965" args="(Type *DataType, int Consecutive) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a97b0835e71d13c9322a3d4c2bbbff965">TargetTransformInfo::isLegalMaskedStore</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>DataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>Consecutive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the target works with masked instruction AVX2 allows masks for consecutive load and store for i32 and i64 elements. </p>
<p>AVX-512 architecture will also allow masks for non-consecutive memory accesses. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00109">109</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9b97e9027fa07134ffb5217b4ce2c77"></a><!-- doxytag: member="llvm::TargetTransformInfo::isLoweredToCall" ref="ad9b97e9027fa07134ffb5217b4ce2c77" args="(const Function *F) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#ad9b97e9027fa07134ffb5217b4ce2c77">TargetTransformInfo::isLoweredToCall</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether calls to a function lower to actual program function calls. </p>
<p>The idea is to test whether the program is likely to require a 'call' instruction or equivalent in order to call the given function.</p>
<p>FIXME: It's not clear that this is a good or useful query API. Client's should probably move to simpler cost metrics using the above. Alternatively, we could split the cost interface into distinct code-size and execution-speed costs. This would allow modelling the core of this query more accurately as a call is a single small instruction, but incurs significant execution cost. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00083">83</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="CodeMetrics_8cpp_source.html#l00111">llvm::CodeMetrics::analyzeBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf0b3d5b94c9d742a2bdb9d221410682"></a><!-- doxytag: member="llvm::TargetTransformInfo::isProfitableToHoist" ref="aaf0b3d5b94c9d742a2bdb9d221410682" args="(Instruction *I) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#aaf0b3d5b94c9d742a2bdb9d221410682">TargetTransformInfo::isProfitableToHoist</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if it is profitable to hoist instruction in the then/else to before if. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00132">132</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="SimplifyCFG_8cpp_source.html#l01055">HoistThenElseCodeToIf()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c11bd87956b475b634021bfcee6bce1"></a><!-- doxytag: member="llvm::TargetTransformInfo::isSourceOfDivergence" ref="a0c11bd87956b475b634021bfcee6bce1" args="(const Value *V) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a0c11bd87956b475b634021bfcee6bce1">TargetTransformInfo::isSourceOfDivergence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether V is a source of divergence. </p>
<p>This function provides the target-dependent information for the target-independent DivergenceAnalysis. DivergenceAnalysis first builds the dependency graph, and then runs the reachability algorithm starting with the sources of divergence. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00079">79</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a547c815fb7093e41196bc8dd0c4b9317"></a><!-- doxytag: member="llvm::TargetTransformInfo::isTruncateFree" ref="a547c815fb7093e41196bc8dd0c4b9317" args="(Type *Ty1, Type *Ty2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a547c815fb7093e41196bc8dd0c4b9317">TargetTransformInfo::isTruncateFree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if it's free to truncate a value of type Ty1 to type Ty2. </p>
<p>e.g. On x86 it's free to truncate a i32 value in register EAX to i16 by referencing its sub-register AX. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00128">128</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="ScalarEvolutionExpander_8cpp_source.html#l01685">llvm::SCEVExpander::replaceCongruentIVs()</a>.</p>

</div>
</div>
<a class="anchor" id="a83f052a0d908e956128c8951451bde39"></a><!-- doxytag: member="llvm::TargetTransformInfo::isTypeLegal" ref="a83f052a0d908e956128c8951451bde39" args="(Type *Ty) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a83f052a0d908e956128c8951451bde39">TargetTransformInfo::isTypeLegal</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if this type is legal. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00136">136</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="SimplifyCFG_8cpp_source.html#l03914">ShouldBuildLookupTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d955ca0eda3479b562ccc505575049b"></a><!-- doxytag: member="llvm::TargetTransformInfo::operator=" ref="a6d955ca0eda3479b562ccc505575049b" args="(TargetTransformInfo &amp;&amp;RHS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp; TargetTransformInfo::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00044">44</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74d97d9e66d1007252d8609b7b8ccf21"></a><!-- doxytag: member="llvm::TargetTransformInfo::shouldBuildLookupTables" ref="a74d97d9e66d1007252d8609b7b8ccf21" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1TargetTransformInfo.html#a74d97d9e66d1007252d8609b7b8ccf21">TargetTransformInfo::shouldBuildLookupTables</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if switches should be turned into lookup tables for the target. </p>

<p>Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00148">148</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p>Referenced by <a class="el" href="SimplifyCFG_8cpp_source.html#l04039">SwitchToLookupTable()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a></li>
<li><a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:10:10 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
